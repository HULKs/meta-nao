From add37d3f910226b16157f0611449e725c0552dd1 Mon Sep 17 00:00:00 2001
From: Kas User <kas@example.com>
Date: Mon, 13 Sep 2021 21:26:45 +0000
Subject: [PATCH] NAO patches (softbank + congatec)

---
 arch/x86/mm/ioremap.c                         |    3 +-
 drivers/Kconfig                               |    2 +
 drivers/Makefile                              |    1 +
 drivers/cgosdrv/COPYING_BSD2                  |   25 +
 drivers/cgosdrv/COPYING_GPL2                  |  339 +++++
 drivers/cgosdrv/Cgeb.c                        |  545 ++++++++
 drivers/cgosdrv/Cgeb.h                        |  389 ++++++
 drivers/cgosdrv/CgebFct.h                     |   56 +
 drivers/cgosdrv/CgebSda.h                     |   59 +
 drivers/cgosdrv/Cgos.h                        |  532 ++++++++
 drivers/cgosdrv/CgosBld.h                     |    3 +
 drivers/cgosdrv/CgosDef.h                     |   54 +
 drivers/cgosdrv/CgosDrv.c                     | 1094 +++++++++++++++++
 drivers/cgosdrv/CgosDrv.h                     |   47 +
 drivers/cgosdrv/CgosIobd.h                    |   38 +
 drivers/cgosdrv/CgosIoct.h                    |  148 +++
 drivers/cgosdrv/CgosPriv.h                    |  121 ++
 drivers/cgosdrv/DrvLx.c                       |  189 +++
 drivers/cgosdrv/DrvOsHdr.h                    |   42 +
 drivers/cgosdrv/DrvOsa.h                      |   56 +
 drivers/cgosdrv/DrvOsaLx.c                    |   91 ++
 drivers/cgosdrv/DrvUla.h                      |   49 +
 drivers/cgosdrv/DrvVars.h                     |  139 +++
 drivers/cgosdrv/Kconfig                       |   25 +
 drivers/cgosdrv/Makefile                      |    5 +
 drivers/cgosdrv/cgos-sbr.c                    |  251 ++++
 drivers/i2c/busses/Kconfig                    |   11 +
 drivers/i2c/busses/Makefile                   |    1 +
 drivers/i2c/busses/sbre-usb-i2c.c             |  438 +++++++
 drivers/mmc/host/sdhci-pci-core.c             |    3 +-
 drivers/usb/misc/Kconfig                      |    2 +
 drivers/usb/misc/Makefile                     |    2 +
 drivers/usb/misc/sbre-dfuse/Kconfig           |   10 +
 drivers/usb/misc/sbre-dfuse/Makefile          |    8 +
 drivers/usb/misc/sbre-dfuse/sbre_dfuse.c      |  703 +++++++++++
 drivers/usb/misc/sbre-dfuse/sbre_dfuse.h      |  107 ++
 .../usb/misc/sbre-dfuse/sbre_dfuse_driver.c   |  179 +++
 drivers/usb/misc/sbre-dfuse/sbre_dfuse_file.c |  119 ++
 drivers/usb/misc/sbre-dfuse/sbre_dfuse_file.h |   53 +
 include/cgos/Cgos.h                           |  532 ++++++++
 include/cgos/CgosIobd.h                       |   38 +
 sound/pci/hda/Kconfig                         |   13 +
 sound/pci/hda/Makefile                        |    2 +
 sound/pci/hda/hda_generic.c                   |    3 +-
 sound/pci/hda/hda_generic.h                   |    1 +
 sound/pci/hda/patch_wolfson.c                 |  608 +++++++++
 46 files changed, 7133 insertions(+), 3 deletions(-)
 create mode 100644 drivers/cgosdrv/COPYING_BSD2
 create mode 100644 drivers/cgosdrv/COPYING_GPL2
 create mode 100644 drivers/cgosdrv/Cgeb.c
 create mode 100644 drivers/cgosdrv/Cgeb.h
 create mode 100644 drivers/cgosdrv/CgebFct.h
 create mode 100644 drivers/cgosdrv/CgebSda.h
 create mode 100644 drivers/cgosdrv/Cgos.h
 create mode 100644 drivers/cgosdrv/CgosBld.h
 create mode 100644 drivers/cgosdrv/CgosDef.h
 create mode 100644 drivers/cgosdrv/CgosDrv.c
 create mode 100644 drivers/cgosdrv/CgosDrv.h
 create mode 100644 drivers/cgosdrv/CgosIobd.h
 create mode 100644 drivers/cgosdrv/CgosIoct.h
 create mode 100644 drivers/cgosdrv/CgosPriv.h
 create mode 100644 drivers/cgosdrv/DrvLx.c
 create mode 100644 drivers/cgosdrv/DrvOsHdr.h
 create mode 100644 drivers/cgosdrv/DrvOsa.h
 create mode 100644 drivers/cgosdrv/DrvOsaLx.c
 create mode 100644 drivers/cgosdrv/DrvUla.h
 create mode 100644 drivers/cgosdrv/DrvVars.h
 create mode 100644 drivers/cgosdrv/Kconfig
 create mode 100644 drivers/cgosdrv/Makefile
 create mode 100644 drivers/cgosdrv/cgos-sbr.c
 create mode 100644 drivers/i2c/busses/sbre-usb-i2c.c
 create mode 100644 drivers/usb/misc/sbre-dfuse/Kconfig
 create mode 100644 drivers/usb/misc/sbre-dfuse/Makefile
 create mode 100644 drivers/usb/misc/sbre-dfuse/sbre_dfuse.c
 create mode 100644 drivers/usb/misc/sbre-dfuse/sbre_dfuse.h
 create mode 100644 drivers/usb/misc/sbre-dfuse/sbre_dfuse_driver.c
 create mode 100644 drivers/usb/misc/sbre-dfuse/sbre_dfuse_file.c
 create mode 100644 drivers/usb/misc/sbre-dfuse/sbre_dfuse_file.h
 create mode 100644 include/cgos/Cgos.h
 create mode 100644 include/cgos/CgosIobd.h
 create mode 100644 sound/pci/hda/patch_wolfson.c

diff --git a/arch/x86/mm/ioremap.c b/arch/x86/mm/ioremap.c
index a353f88d299d..d441244991af 100644
--- a/arch/x86/mm/ioremap.c
+++ b/arch/x86/mm/ioremap.c
@@ -289,7 +289,8 @@ __ioremap_caller(resource_size_t phys_addr, unsigned long size,
 	 * Check if the request spans more than any BAR in the iomem resource
 	 * tree.
 	 */
-	if (iomem_map_sanity_check(unaligned_phys_addr, unaligned_size))
+	if (phys_addr != 0xff800000 &&
+			iomem_map_sanity_check(unaligned_phys_addr, unaligned_size))
 		pr_warn("caller %pS mapping multiple BARs\n", caller);
 
 	return ret_addr;
diff --git a/drivers/Kconfig b/drivers/Kconfig
index 8befa53f43be..0bc19bc7dbf3 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -24,6 +24,8 @@ source "drivers/of/Kconfig"
 
 source "drivers/parport/Kconfig"
 
+source "drivers/cgosdrv/Kconfig"
+
 source "drivers/pnp/Kconfig"
 
 source "drivers/block/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index aaef17cc6512..cff2ecf81d62 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -178,6 +178,7 @@ obj-$(CONFIG_STM)		+= hwtracing/stm/
 obj-$(CONFIG_ANDROID)		+= android/
 obj-$(CONFIG_NVMEM)		+= nvmem/
 obj-$(CONFIG_FPGA)		+= fpga/
+obj-$(CONFIG_CGOS)		+= cgosdrv/
 obj-$(CONFIG_FSI)		+= fsi/
 obj-$(CONFIG_TEE)		+= tee/
 obj-$(CONFIG_MULTIPLEXER)	+= mux/
diff --git a/drivers/cgosdrv/COPYING_BSD2 b/drivers/cgosdrv/COPYING_BSD2
new file mode 100644
index 000000000000..41b64bc6b642
--- /dev/null
+++ b/drivers/cgosdrv/COPYING_BSD2
@@ -0,0 +1,25 @@
+Copyright (c) 2018 congatec AG. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+
+1. Redistributions of source code must retain the above copyright 
+   notice, this list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE 
+COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
+BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+OF SUCH DAMAGE.
diff --git a/drivers/cgosdrv/COPYING_GPL2 b/drivers/cgosdrv/COPYING_GPL2
new file mode 100644
index 000000000000..d159169d1050
--- /dev/null
+++ b/drivers/cgosdrv/COPYING_GPL2
@@ -0,0 +1,339 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+                            NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
diff --git a/drivers/cgosdrv/Cgeb.c b/drivers/cgosdrv/Cgeb.c
new file mode 100644
index 000000000000..d55e5210c95b
--- /dev/null
+++ b/drivers/cgosdrv/Cgeb.c
@@ -0,0 +1,545 @@
+/*---------------------------------------------------------------------------
+ *
+ * Copyright (c) 2015, congatec AG. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version 2 of 
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation, 
+ * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * The full text of the license may also be found at:        
+ * http://opensource.org/licenses/GPL-2.0
+ *
+ *---------------------------------------------------------------------------
+ */ 
+
+//***************************************************************************
+
+#include "linux/types.h"
+#include "CgosDrv.h"
+
+//***************************************************************************
+
+#ifdef DBPF
+
+char *CgebNames[]={
+  // wait until function numbers are stable
+  };
+
+#define dbpfCgebNames(names,fct) \
+  { if (fct<sizeof(names)/sizeof(*names)) \
+  dbpf((TT("CGOS: xCgeb%s\n"),names[fct])); }
+
+#define dbpfCgebName(fct) \
+  { dbpfCgebNames(CgebNames,fct) }
+
+#else
+
+#define dbpfCgebName(fct)
+
+#endif
+
+//***************************************************************************
+
+#if defined(CGEB_LINKED_IN) || defined (AMD64)
+unsigned short GetDS(void)
+  {
+  return 0;
+  }
+
+#elif defined _MSC_VER // MS VC
+
+#pragma warning(disable: 4035)
+
+unsigned short GetDS(void)
+  {
+  _asm mov ax,ds
+  }
+
+#pragma warning(default: 4035)
+
+#elif defined __WATCOMC__
+
+unsigned short GetDS(void);
+#pragma aux GetDS="mov ax,ds" value [ax];
+
+#else // GNU C
+
+// this would work with MSVC as well but XPSP2++ execute protection could cause problems
+
+unsigned short GetDS(void)
+  {
+  static unsigned char GetDSRaw[]= { // cs would be 0xC8
+    0x8C, 0xD8,         // mov ax,ds
+    0xC3                // ret
+    };
+  return ((unsigned short (*)(void))GetDSRaw)();
+  }
+
+#endif // CGEB_LINKED_IN
+
+#if (!defined(_MSC_VER) && !defined(__cdecl))
+#define __cdecl
+#endif
+
+void CgebCall(CGEBFPS *fps, void *addr)
+  {
+#if !defined(AMD64) || defined(CGEBEMU)
+  // addr points to a bimodal C style function that expects a far pointer to an fps.
+  // if cs is 0 then it does a near return, otherwise a far return.
+  // if we ever need a far return then we must not pass cs at all.
+  // parameters are removed by the caller
+  ((void (__cdecl *)(unsigned short cs, CGEBFPS *fps, unsigned short ds))addr)(0,fps,fps->data.seg);
+#else
+  // CGEBQ expects FPS in edx (ecx is reserved and must be 0)
+  // x64 (MS) calling convention is rcx, rdx, r8, r9
+  // ABI (linux) calling convention rdi, rsi, rdx, rcx
+  // parameters are removed by the caller
+  ((void (*)(void *, CGEBFPS *fps, CGEBFPS *fps_abi, void *))addr)(NULL,fps,fps,NULL);
+#endif
+  }
+
+//***************************************************************************
+
+unsigned int CgebInvokeStep(CGOS_DRV_CGEB *cgeb, CGEBFPS *fps)
+  {
+  dbpf((TT("CGOS: CGEB: ->  size %02X, fct %02X, data %04X:%08X, status %08X\n"),
+    fps->size,fps->fct,fps->data.seg,fps->data.off,fps->status));
+  CgebCall(fps,cgeb->entry);
+  dbpf((TT("CGOS:  <- CGEB: size %02X, fct %02X, data %04X:%08X, status %08X\n"),
+    fps->size,fps->fct,fps->data.seg,fps->data.off,fps->status));
+  return fps->status;
+  }
+
+unsigned int CgebInvokeFirstStep(CGOS_DRV_CGEB *cgeb, CGEBFPS *fps, unsigned int size, unsigned int fct)
+  {
+  fps->size=(size)?size:sizeof(CGEBFPS);
+  fps->fct=fct;
+  fps->data.off=cgeb->data;
+  fps->data.seg=cgeb->ds;
+  fps->data.pad=0;
+/*
+  fps->ptrs[0].seg=cgeb->ds;
+  fps->ptrs[0].pad=0;
+  fps->ptrs[1].seg=cgeb->ds;
+  fps->ptrs[1].pad=0;
+*/
+  fps->status=CGEB_SUCCESS;
+  fps->cont=fps->subfct=fps->subfps=0;
+  if (!cgeb->entry) return CGEB_ERROR;
+  dbpfCgebName(fct);
+  return CgebInvokeStep(cgeb,fps);
+  }
+
+unsigned int CgebInvoke(CGOS_DRV_CGEB *cgeb, CGEBFPS *fps, unsigned int size, unsigned int fct)
+  {
+  CgebInvokeFirstStep(cgeb,fps,size,fct);
+  for (;;) {
+    switch (fps->status) {
+      case CGEB_SUCCESS: return TRUE;
+      case CGEB_NEXT: break; // simply call again
+
+      case CGEB_NOIRQS:
+        OsaSleepms(cgeb,0); // call again with a full time slice
+        break;
+
+      case CGEB_DELAY:
+        if (fps->rets[0]<1000) // less then 1 ms
+          OsaWaitus(cgeb,fps->rets[0]);
+        else
+          OsaSleepms(cgeb,(fps->rets[0]+999)/1000);
+        break;
+
+      case CGEB_DBG_STR:
+//        if (fps->rets[0]) dbpf((TT("CGEB: %s\n"),(unsigned char *)fps->rets[0]));
+        if (fps->optr) dbpf((TT("CGEB: %s\n"),(unsigned char *)fps->optr));
+        break;
+
+      case CGEB_DBG_HEX: dbpf((TT("CGEB: 0x%08X\n"),fps->rets[0])); break;
+      case CGEB_DBG_DEC: dbpf((TT("CGEB: %d\n"),fps->rets[0])); break;
+
+      default:
+        if ((int)fps->status>0) // unknown continuation code
+          fps->status=CGEB_ERROR;
+        return FALSE;
+      }
+    CgebInvokeStep(cgeb,fps);
+    }
+  }
+
+unsigned int CgebInvokePlain(CGOS_DRV_CGEB *cgeb, unsigned int fct, unsigned int *pRes)
+  {
+  CGEBFPS fps;
+  unsigned int ret;
+  OsaMemSet(&fps,0,sizeof(fps));
+  ret=CgebInvoke(cgeb,&fps,sizeof(fps),fct);
+  if (pRes) *pRes=fps.rets[0];
+  return ret;
+  }
+
+unsigned int CgebInvokeRetUnit(CGOS_DRV_CGEB *cgeb, unsigned int flags, unsigned int fct, unsigned int unit, unsigned int *pRes)
+  {
+  CGEBFPS fps;
+  unsigned int ret;
+  OsaMemSet(&fps,0,sizeof(fps));
+  fps.unit=unit;
+  ret=CgebInvoke(cgeb,&fps,sizeof(fps),fct);
+  if (pRes) {
+    *pRes=fps.status;
+    if (flags&1) *pRes=fps.rets[0];
+    if (flags&2) *pRes=fps.status;
+    if (flags&4) *(void **)pRes=fps.optr;
+    }
+  return ret;
+  }
+
+unsigned int CgebInvokeRet(CGOS_DRV_CGEB *cgeb, unsigned int flags, unsigned int fct, unsigned int *pRes)
+  {
+  return CgebInvokeRetUnit(cgeb,flags,fct,0,pRes);
+  }
+
+unsigned int CgebInvokeVoid(CGOS_DRV_CGEB *cgeb, CGEBFPS *fps, unsigned int size)
+  {
+  if (size<sizeof(CGEBFPS)) return FALSE;
+  return CgebInvoke(cgeb,fps,size,fps->fct);
+  }
+
+
+unsigned int CgebInvokePar(CGOS_DRV_CGEB *cgeb, unsigned int flags, unsigned int fct,
+    unsigned int unit, unsigned int par0, unsigned int par1,
+    unsigned int par2, unsigned int par3, unsigned int *pret0, unsigned int *pret1)
+  {
+  CGEBFPS fps;
+  fps.fct=fct;
+  fps.unit=unit;
+  fps.pars[0]=par0;
+  fps.pars[1]=par1;
+  fps.pars[2]=par2;
+  fps.pars[3]=par3;
+  fps.iptr=0;
+  fps.optr=0;
+  if (!CgebInvoke(cgeb,&fps,sizeof(fps),fct)) return FALSE;
+  if (pret0) *pret0=fps.rets[0];
+  if (pret1) *pret1=fps.rets[1];
+  if (flags&1) return fps.rets[0];
+  if (flags&2) return fps.status;
+//  if (flags&4) return (unsigned int)fps.optr; // unsupported
+  return TRUE;
+  }
+
+unsigned int CgebInvokeIoctl(CGOS_DRV_CGEB *cgeb, unsigned int flags, unsigned int fct,
+  CGOS_DRV_VARS *cdv)
+  {
+  CGEBFPS fps;
+  CGOSIOCTLIN *cin=cdv->cin;
+  CGOSIOCTLOUT *cout=cdv->cout;
+  unsigned int fixlen=0;
+  fps.fct=fct;
+  fps.unit=cdv->unit; //cin->type;
+  fps.pars[0]=cin->pars[0];
+  fps.pars[1]=cin->pars[1];
+  fps.pars[2]=cin->pars[2];
+  fps.pars[3]=cin->pars[3];
+  fps.iptr=0;
+  fps.optr=0;
+  if (cdv->lout) fps.optr=cout+1;
+  if (cdv->lin) fps.iptr=cin+1;
+  if (!CgebInvoke(cgeb,&fps,sizeof(fps),fct)) return FALSE;
+  if (flags&16 && fps.optr) {
+    cdv->retcnt=*(unsigned int *)fps.optr; // retcnt from returned buffer size
+    if (cdv->retcnt>cdv->lout) {
+      cdv->retcnt=cdv->lout;
+      fixlen=1;
+      }
+    }
+  if (cdv->retcnt && fps.optr && fps.optr!=cout+1)
+    OsaMemCpy(cout+1,fps.optr,cdv->retcnt); // CGEB returned a different fps.optr so we must copy
+  if (fixlen) *(unsigned int *)(cout+1)=cdv->lout;
+  // on these CGEB always uses the caller supplied buffer, so there's no need to copy
+  if (flags&32) cdv->retcnt=fps.rets[0]; // number of bytes read
+  if (flags&64) cdv->retcnt=fps.pars[0]; // number of bytes read from input pars0
+  if (flags&128) cdv->retcnt=fps.pars[1]; // number of bytes read from input pars1
+  cout->rets[0]=fps.rets[0];
+  cout->rets[1]=fps.rets[1];
+  cdv->status=fps.status;
+  if (flags&1) return fps.rets[0];
+  if (flags&2) return fps.status;
+  return TRUE;
+  }
+
+//***************************************************************************
+//***************************************************************************
+
+unsigned int CgebInvokePars(CGOS_DRV_CGEB *cgeb, unsigned int fct, unsigned int num,
+    unsigned int *pars, unsigned int back, unsigned int *pRes)
+  {
+  CGEBFPS_PARS fps;
+  unsigned int ret;
+  unsigned int i;
+  if (num>CGEB_PARS_MAX) return FALSE;
+  for (i=0; i<num; i++) fps.pars[i]=pars[i];
+  ret=CgebInvoke(cgeb,&fps.fps,CGEB_PARS_SIZE(num),fct);
+  if (back && ret)
+    for (i=0; i<num; i++) pars[i]=fps.pars[i];
+  *pRes=fps.fps.rets[0];
+  return ret;
+  }
+
+//***************************************************************************
+//***************************************************************************
+
+void OsaWaitus(void *ctx, unsigned int us)
+  {
+  CGEBFPS fps;
+  OsaMemSet(&fps,0,sizeof(fps));
+  if (!ctx || CgebInvokeFirstStep((CGOS_DRV_CGEB *)ctx,&fps,sizeof(fps),xCgebDelayUs)) {
+    unsigned int i;
+    // do the best we can
+    while (us--)
+      for (i=10000; i; i--);
+    }
+  }
+
+//***************************************************************************
+//***************************************************************************
+
+unsigned char *CgebScanMem(unsigned char *p, unsigned char *pend, char *magic)
+  {
+  unsigned int magic0=((unsigned int *)magic)[0];
+  unsigned int magic1=((unsigned int *)magic)[1];
+  for (; p<pend; p+=16)
+    if (*(unsigned int *)p==magic0 && ((unsigned int *)p)[1]==magic1)
+      return p;
+  return NULL;
+  }
+
+unsigned int SdaReadToInfo(CGOS_DRV_BOARD *brd);
+
+unsigned int CgebOpenRaw(CGOS_DRV_BOARD *brd, unsigned char *pcur, unsigned char *pend, unsigned char **ppnext)
+  {
+  unsigned int dw, i;
+  CGOS_DRV_CGEB *cgeb=&brd->cgeb;
+  CGOSBOARDINFOA *pb=&brd->info;
+  CGEB_BOARDINFO *pbi;
+  CGEB_LO_DESC *loDesc;
+  CGEB_HI_DESC *hiDesc=NULL;
+  unsigned int hiStart=0xFFF00000;
+  CGEB_STORAGEAREA_INFO *psto;
+
+  OsaMemSet(cgeb,0,sizeof(CGOS_DRV_CGEB));
+
+  if (!pend)
+    cgeb->entry=pcur; // if pend is NULL then pcur is the entry function
+  else {
+    dbpf((TT("CGOS: Looking for CGEB lo desc between virt 0x%X and 0x%X\n"),pcur,pend));
+
+    // look for the next CGEB descriptor
+    *ppnext=NULL;
+    pcur=CgebScanMem(pcur,pend,CGEB_LD_MAGIC);
+
+    if (!pcur) return FALSE; // nothing found
+    *ppnext=pcur+16; // next paragraph
+
+    dbpf((TT("CGOS: Found CGEB_LD_MAGIC\n")));
+
+    loDesc=(CGEB_LO_DESC *)pcur;
+    if (loDesc->size<sizeof(CGEB_LO_DESC)-sizeof(int)) return FALSE;
+    if (loDesc->size>=sizeof(CGEB_LO_DESC) && loDesc->hiDescPhysAddr)
+      hiStart=loDesc->hiDescPhysAddr;
+
+    cgeb->hiDescLen=(unsigned int)-(int)hiStart;
+    dbpf((TT("CGOS: Looking for CGEB hi desc between phys 0x%X and 0x%X\n"),hiStart,-1));
+    cgeb->hiDescStart=(unsigned char *)OsaMapAddress(hiStart,cgeb->hiDescLen);
+    if (!cgeb->hiDescStart) return FALSE;
+    dbpf((TT("CGOS: Looking for CGEB hi desc between virt 0x%X and 0x%X\n"),cgeb->hiDescStart,cgeb->hiDescStart+cgeb->hiDescLen-1));
+    hiDesc=(CGEB_HI_DESC *)CgebScanMem(cgeb->hiDescStart,cgeb->hiDescStart+cgeb->hiDescLen-1,CGEB_HD_MAGIC);
+    if (!hiDesc) return FALSE;
+
+    dbpf((TT("CGOS: Found CGEB_HD_MAGIC\n")));
+
+    if (hiDesc->size<sizeof(CGEB_HI_DESC)) return FALSE;
+
+    dbpf((TT("CGOS: dataSize %u, codeSize %u, entryRel %u\n"),hiDesc->dataSize,hiDesc->codeSize,hiDesc->entryRel));
+
+    cgeb->code=OsaMemAlloc(hiDesc->codeSize);
+    if (!cgeb->code) return FALSE;
+
+    // copy the code
+    OsaMemCpy(cgeb->code,hiDesc,hiDesc->codeSize);
+
+    // free the hi descriptor mapping and switch the pointer to our copied code
+    OsaUnMapAddress(cgeb->hiDescStart,cgeb->hiDescLen);
+    cgeb->hiDescStart=NULL;
+    hiDesc=(CGEB_HI_DESC *)cgeb->code;
+
+    cgeb->entry=(void *)((unsigned char *)cgeb->code+hiDesc->entryRel);
+    }
+  dbpf((TT("CGOS: entry point at 0x%X\n"),cgeb->entry));
+  cgeb->ds=GetDS();
+
+  // check the revision
+  if (!CgebInvokePlain(cgeb,xCgebGetCgebVersion,&dw)) return FALSE;
+  if (CGEB_GET_VERSION_MAJOR(dw)!=CGEB_VERSION_MAJOR) return FALSE;
+  pb->dwSize=sizeof(*pb);
+  pb->wBiosInterfaceRevision=(unsigned short)(dw>>16);
+  pb->wBiosInterfaceBuildRevision=(unsigned short)dw;
+
+  // allocate the data area
+  if (hiDesc && hiDesc->dataSize) {
+    cgeb->data=OsaMemAlloc(hiDesc->dataSize);
+    if (!cgeb->data) return FALSE;
+    }
+  else if (CgebInvokePlain(cgeb,xCgebGetDataSize,&dw) && dw) {
+    cgeb->data=OsaMemAlloc(dw);
+    if (!cgeb->data) return FALSE;
+    }
+
+  // init the data
+  if (!CgebInvokePlain(cgeb,xCgebOpen,NULL)) return FALSE;
+
+  if (CgebInvokeRet(cgeb,4,xCgebMapGetMem,(void *)&cgeb->mapMem) && cgeb->mapMem) {
+    CGEB_MAP_MEM_LIST *pmm;
+    CGEB_MAP_MEM * pmme;
+    unsigned int i;
+    pmm=(CGEB_MAP_MEM_LIST *)cgeb->mapMem;
+    pmme=pmm->entries;
+    dbpf((TT("CGOS: Memory Map with %u entries\n"),pmm->count));
+    for (i=pmm->count; i; i--, pmme++) {
+      if (pmme->phys && pmme->size) {
+        pmme->virt.off=OsaMapAddress((uintptr_t)pmme->phys,pmme->size); // !!! upper 32 bits are lost !!!
+        if (!pmme->virt.off) return FALSE;
+        }
+      else pmme->virt.off=0;
+      pmme->virt.seg=(pmme->virt.off)?cgeb->ds:0;
+            dbpf((TT("CGOS:   Map phys %08X, size %08X, virt %04X:%08X\n"),
+              pmme->phys,pmme->size,pmme->virt.seg,pmme->virt.off));
+      }
+    CgebInvokePlain(cgeb,xCgebMapChanged,NULL);
+    }
+
+  // get the board info
+  if (!CgebInvokeRet(cgeb,4,xCgebBoardGetInfo,(void *)&pbi)) return FALSE;
+
+  dbpf((TT("CGOS: Board name: %c%c%c%c\n"),pbi->szBoard[0],pbi->szBoard[1],pbi->szBoard[2],pbi->szBoard[3]));
+
+  // store the board info
+  OsaMemCpy(pb->szBoard,pbi->szBoard,sizeof(pb->szBoard));
+  pb->dwPrimaryClass=pbi->dwPrimaryClass;
+  pb->dwClasses=pbi->dwClasses|pbi->dwPrimaryClass;
+  if (pbi->dwSize>(unsigned int)((char *)pbi->szVendor-(char *)pbi) && *pbi->szVendor)
+    OsaMemCpy(pb->szManufacturer,pbi->szVendor,sizeof(pbi->szVendor));
+  else
+    OsaMemCpy(pb->szManufacturer,"congatec",9);
+
+  // storage areas
+  CgebInvokePlain(cgeb,xCgebStorageAreaCount,&brd->stoCount);
+  if (brd->stoCount>CGOS_DRV_STO_MAX) brd->stoCount=CGOS_DRV_STO_MAX;
+  for (i=0; i<brd->stoCount; i++)
+    if (CgebInvokeRetUnit(cgeb,4,xCgebStorageAreaGetInfo,i,(void *)&psto) && psto)
+      brd->sto[i].info=*psto;
+
+  CgebInvokePlain(cgeb,xCgebI2CCount,&brd->i2cCount);
+//  if (brd->i2cCount>CGOS_DRV_I2C_MAX) brd->i2cCount=CGOS_DRV_I2C_MAX;
+
+  CgebInvokePlain(cgeb,xCgebWDogCount,&brd->wdogCount);
+  if (brd->wdogCount>CGOS_DRV_WDOG_MAX) brd->wdogCount=CGOS_DRV_WDOG_MAX;
+
+  // complete the board info, it needs the storage areas
+  SdaReadToInfo(brd);
+  if (CgebInvokePlain(cgeb,xCgebGetSysBiosVersion,&dw))
+    pb->wSystemBiosRevision=(unsigned short)(dw>>16);
+
+  dbpf((TT("CGOS: CgebOpenRaw() successful!\n")));
+  return TRUE;
+  }
+
+//***************************************************************************
+
+void CgebClose(CGOS_DRV_CGEB *cgeb)
+  {
+  if (cgeb->entry)
+    CgebInvokePlain(cgeb,xCgebClose,NULL);
+
+  if (cgeb->hiDescStart) {
+    OsaUnMapAddress(cgeb->hiDescStart,cgeb->hiDescLen);
+    cgeb->hiDescStart=NULL;
+    }
+
+  if (cgeb->mapMem) {
+    CGEB_MAP_MEM_LIST *pmm;
+    CGEB_MAP_MEM * pmme;
+    unsigned int i;
+    pmm=(CGEB_MAP_MEM_LIST *)cgeb->mapMem;
+    pmme=pmm->entries;
+    for (i=pmm->count; i; i--, pmme++) {
+      if (pmme->virt.off) OsaUnMapAddress((void *)pmme->virt.off,pmme->size);
+      pmme->virt.off=0;
+      pmme->virt.seg=0;
+      }
+    }
+  if (cgeb->data) {
+    OsaMemFree(cgeb->data);
+    cgeb->data=NULL;
+    cgeb->ds=0;
+    }
+  if (cgeb->code) {
+    OsaMemFree(cgeb->code);
+    cgeb->code=NULL;
+    }
+  cgeb->entry=NULL;
+  }
+
+//***************************************************************************
+
+unsigned int CgebOpen(CGOS_DRV_VARS *cdv, unsigned char *base, unsigned int len)
+  {
+  unsigned char *p,*pnext;
+  CGOS_DRV_BOARD *brd=cdv->boards+cdv->boardCount;
+  CGOS_DRV_CGEB *cgeb=&brd->cgeb;
+  if (cdv->boardCount>=CGOS_DRV_BOARD_MAX) return FALSE;
+
+  if (!len) {
+    dbpf((TT("CGOS: Registering CGEB entry function at 0x%X\n"),(unsigned int)base));
+    if (!CgebOpenRaw(brd,base,NULL,&pnext)) {
+      CgebClose(cgeb);
+      return FALSE;
+      }
+    cdv->boardCount++;
+    return TRUE;
+    }
+
+  dbpf((TT("CGOS: Looking for CGEB lo desc between phys 0x%X and 0x%X\n"),(unsigned int)base,(unsigned int)base+len));
+  p=(unsigned char *)(uintptr_t)OsaMapAddress((uintptr_t)base,len);
+  if (!p) return FALSE;
+  if (!CgebOpenRaw(brd,p,p+len,&pnext)) {
+    CgebClose(cgeb);
+    OsaUnMapAddress(p,len);
+    return FALSE;
+    }
+
+  OsaUnMapAddress(p,len);
+  cdv->boardCount++;
+  return TRUE;
+  }
+
+//***************************************************************************
+
+unsigned int CgebTransAddr(CGOS_DRV_CGEB *cgeb, unsigned int addr)
+  {
+  switch (addr) {
+    case -2: addr=(uintptr_t)cgeb->code; break; // !!! 64
+    case -3: addr=(uintptr_t)cgeb->data; break;
+    }
+  return addr;
+  }
+
+//***************************************************************************
diff --git a/drivers/cgosdrv/Cgeb.h b/drivers/cgosdrv/Cgeb.h
new file mode 100644
index 000000000000..c06c132d6516
--- /dev/null
+++ b/drivers/cgosdrv/Cgeb.h
@@ -0,0 +1,389 @@
+/*---------------------------------------------------------------------------
+ *
+ * Copyright (c) 2015, congatec AG. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version 2 of 
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation, 
+ * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * The full text of the license may also be found at:        
+ * http://opensource.org/licenses/GPL-2.0
+ *
+ *---------------------------------------------------------------------------
+ */ 
+
+//***************************************************************************
+
+#ifndef _CGEB_H_
+#define _CGEB_H_
+
+//***************************************************************************
+
+#pragma pack(push,4)
+
+//***************************************************************************
+//
+// Current major version number
+//
+
+#define CGEB_VERSION_MAJOR 1
+
+//***************************************************************************
+
+#define CGEB_GET_VERSION_MAJOR(v) (((unsigned int)(v))>>24)
+#define CGEB_GET_VERSION_MINOR(v) ((((unsigned int)(v))>>16)&0xff)
+#define CGEB_GET_VERSION_BUILD(v) (((unsigned int)(v))&0xffff)
+
+//***************************************************************************
+//
+// CGEB far pointer
+//
+
+typedef struct {
+  void *off;
+  unsigned short seg;
+  unsigned short pad;
+  } CGEBFPTR;
+
+//***************************************************************************
+//
+// CGEB Low Descriptor located in 0xC0000-0xFFFFF
+//
+
+#define CGEB_LD_MAGIC "$CGEBLD$"
+
+typedef struct {
+  char magic[8];                // descriptor magic string
+  unsigned short size;          // size of this descriptor
+  unsigned short reserved;
+  char biosName[8];             // BIOS name and revision "ppppRvvv"
+  unsigned int hiDescPhysAddr; // phys addr of the high descriptor (can be 0)
+                                // can also be a search hint
+  } CGEB_LO_DESC;
+
+//***************************************************************************
+//
+// CGEB High Descriptor located in 0xFFF00000-0xFFFFFFFF
+//
+
+#if defined(AMD64) 
+#define CGEB_HD_MAGIC "$CGEBQD$"
+#else
+#define CGEB_HD_MAGIC "$CGEBHD$"
+#endif
+
+typedef struct {
+  char magic[8];                // descriptor magic string
+  unsigned short size;          // size of this descriptor
+  unsigned short reserved;
+  unsigned int dataSize;       // CGEB data area size
+  unsigned int codeSize;       // CGEB code area size
+  unsigned int entryRel;
+  } CGEB_HI_DESC;
+
+//***************************************************************************
+//
+// CGEB function parameter structure
+//
+
+typedef struct {
+  unsigned int size;    // size of the parameter structure
+  unsigned int fct;     // function number
+  CGEBFPTR data;         // CGEB data area
+  void *cont;    // private continuation pointer
+  void *subfps;  // private sub function parameter structure pointer
+  void *subfct;  // private sub function pointer
+  unsigned int status;  // result codes of the function
+  unsigned int unit;    // unit number or type
+  unsigned int pars[4]; // input parameters
+  unsigned int rets[2]; // return parameters
+  void *iptr;            // input pointer
+  void *optr;            // output pointer
+  } CGEBFPS;
+
+// Generic unsigned int parameter request block
+
+#define CGEB_PARS_MAX 16
+
+typedef struct {
+  CGEBFPS fps;                // CGEB function parameter structure
+  unsigned int pars[CGEB_PARS_MAX];  // parameters
+  } CGEBFPS_PARS;
+
+#define CGEB_PARS_SIZE(n) (sizeof(CGEBFPS)+(n)*sizeof(unsigned int))
+
+//
+// result status codes
+//
+
+#define CGEB_SUCCESS            0
+#define CGEB_ERROR             -1
+#define CGEB_INVALID_PARAMETER -2
+#define CGEB_NOT_FOUND         -3
+#define CGEB_READ_ERROR        -4
+#define CGEB_WRITE_ERROR       -5
+#define CGEB_TIMEOUT           -6
+
+//
+// continuation status codes
+//
+
+#define CGEB_NEXT               1
+#define CGEB_DELAY              2
+#define CGEB_NOIRQS             3
+
+#define CGEB_DBG_STR        0x100
+#define CGEB_DBG_HEX        0x101
+#define CGEB_DBG_DEC        0x102
+
+//***************************************************************************
+//
+// CGEB interface functions
+//
+
+#define xCgebGetCgebVersion            0
+#define xCgebGetSysBiosVersion         1
+#define xCgebGetVgaBiosVersion         2
+#define xCgebGetDataSize               3
+#define xCgebOpen                      4
+#define xCgebClose                     5
+#define xCgebMapGetMem                 6
+#define xCgebMapChanged                7
+#define xCgebMapGetPorts               8
+#define xCgebDelayUs                   9
+#define xCgebCgbcReadWrite            10
+#define xCgebCgbcSetControl           11
+#define xCgebCgbcGetInfo              12
+#define xCgebCgbcHandleCommand        13
+#define xCgebBoardGetInfo             14
+#define xCgebBoardGetBootCounter      15
+#define xCgebBoardGetRunningTimeMeter 16
+#define xCgebBoardGetBootErrorLog     17
+#define xCgebVgaCount                 18
+#define xCgebVgaGetInfo               19
+#define xCgebVgaGetContrast           20
+#define xCgebVgaSetContrast           21
+#define xCgebVgaGetContrastEnable     22
+#define xCgebVgaSetContrastEnable     23
+#define xCgebVgaGetBacklight          24
+#define xCgebVgaSetBacklight          25
+#define xCgebVgaGetBacklightEnable    26
+#define xCgebVgaSetBacklightEnable    27
+#define xCgebVgaEndDarkBoot           28
+#define xCgebStorageAreaCount         29
+#define xCgebStorageAreaGetInfo       30
+#define xCgebStorageAreaRead          31
+#define xCgebStorageAreaWrite         32
+#define xCgebStorageAreaErase         33
+#define xCgebStorageAreaEraseStatus   34
+#define xCgebI2CCount                 35
+#define xCgebI2CGetInfo               36
+#define xCgebI2CGetAddrList           37
+#define xCgebI2CTransfer              38
+#define xCgebI2CGetFrequency          39
+#define xCgebI2CSetFrequency          40
+#define xCgebIOCount                  41
+#define xCgebIOGetInfo                42
+#define xCgebIORead                   43
+#define xCgebIOWrite                  44
+#define xCgebIOGetDirection           45
+#define xCgebIOSetDirection           46
+#define xCgebWDogCount                47
+#define xCgebWDogGetInfo              48
+#define xCgebWDogTrigger              49
+#define xCgebWDogGetConfig            50
+#define xCgebWDogSetConfig            51
+#define xCgebPerformanceGetCurrent    52
+#define xCgebPerformanceSetCurrent    53
+#define xCgebPerformanceGetPolicyCaps 54
+#define xCgebPerformanceGetPolicy     55
+#define xCgebPerformanceSetPolicy     56
+#define xCgebTemperatureCount         57
+#define xCgebTemperatureGetInfo       58
+#define xCgebTemperatureGetCurrent    59
+#define xCgebTemperatureSetLimits     60
+#define xCgebFanCount                 61
+#define xCgebFanGetInfo               62
+#define xCgebFanGetCurrent            63
+#define xCgebFanSetLimits             64
+#define xCgebVoltageCount             65
+#define xCgebVoltageGetInfo           66
+#define xCgebVoltageGetCurrent        67
+#define xCgebVoltageSetLimits         68
+#define xCgebStorageAreaLock          69
+#define xCgebStorageAreaUnlock        70
+#define xCgebStorageAreaIsLocked      71
+
+//***************************************************************************
+//
+// xCgebMapGetMem
+//
+
+typedef struct {
+  void *phys;     // physical address
+  unsigned int size;     // size in bytes
+  CGEBFPTR virt;
+  } CGEB_MAP_MEM;
+
+typedef struct {
+  unsigned int count; // number of memory map entries
+  CGEB_MAP_MEM entries[1];
+  } CGEB_MAP_MEM_LIST;
+
+//***************************************************************************
+//
+// xCgebMapGetPorts
+//
+
+typedef struct {
+  unsigned short port;
+  unsigned short size;
+  } CGEB_MAP_PORT;
+
+typedef struct {
+  unsigned int count;
+  CGEB_MAP_PORT entries[1];
+  } CGEB_MAP_PORT_LIST;
+
+#define CGEB_MAP_PORT_EXCLUSIVE 0x8000
+
+//***************************************************************************
+//
+// xCgebBoardGetInfo
+//
+
+typedef struct {
+  unsigned int dwSize;
+  unsigned int dwFlags;
+  unsigned int dwClasses;
+  unsigned int dwPrimaryClass;
+  char szBoard[CGOS_BOARD_MAX_SIZE_ID_STRING];
+  // optional
+  char szVendor[CGOS_BOARD_MAX_SIZE_ID_STRING];
+  } CGEB_BOARDINFO;
+
+//***************************************************************************
+//
+// xCgebStorageAreaGetInfo
+//
+
+typedef struct {
+  unsigned int size;
+  unsigned int type;
+  unsigned int flags;
+  unsigned int areaSize;
+  unsigned int blockSize;
+  } CGEB_STORAGEAREA_INFO;
+
+
+// private storage area types
+
+#define CGOS_STORAGE_AREA_SDA           0x00050000
+#define CGOS_STORAGE_AREA_EEPROM_BIOS   0x40010000
+#define CGOS_STORAGE_AREA_RAM_BIOS      0x40040000
+
+#define CGOS_STORAGE_AREA_FLASH_STATIC  0x40020001
+#define CGOS_STORAGE_AREA_FLASH_DYNAMIC 0x40020000
+#define CGOS_STORAGE_AREA_FLASH_ALL     0x80020000
+
+#define CGOS_STORAGE_AREA_MPFA          0x00060000
+
+/*
+IP (dynamic)
+BootLogo (static)
+CMOS Backup (dynamic)
+CMOS Default Map (static)
+Bootloader (static)
+User Code (static)
+Panel Data Table (static)
+*/
+
+#define CGOS_STORAGE_AREA_EEPROM_IP  0x01010000
+
+//***************************************************************************
+//
+// I2C bus address list
+//
+
+typedef struct {
+  unsigned char address;
+  unsigned char flags;
+  unsigned short deviceType;
+  } CGEB_I2C_DEV;
+
+typedef struct {
+  unsigned int count;
+  CGEB_I2C_DEV entries[1];
+  } CGEB_I2C_LIST;
+
+// Device Flags
+
+#define CGEB_I2C_DEVFLAGS_OPTIONAL 1
+
+// Device Types
+
+#define CGEB_I2C_DEVTYPE_UNKNOWN        0
+#define CGEB_I2C_DEVTYPE_EEPROM         1
+#define CGEB_I2C_DEVTYPE_DAC            2
+#define CGEB_I2C_DEVTYPE_DAC_BACKLIGHT  3
+#define CGEB_I2C_DEVTYPE_DAC_CONTRAST   4
+
+typedef struct {
+  unsigned int size;
+  unsigned int type;
+  unsigned int frequency;
+  unsigned int maxFrequency;
+  } CGEB_I2C_INFO;
+
+// I2C Types
+
+#define CGEB_I2C_TYPE_UNKNOWN 0
+#define CGEB_I2C_TYPE_PRIMARY 1
+#define CGEB_I2C_TYPE_SMB     2
+#define CGEB_I2C_TYPE_DDC     3
+#define CGEB_I2C_TYPE_BC      4
+
+// xCgebI2CTransfer flags
+
+#define CG_I2C_FLAG_START   0x00080 // send START condition
+#define CG_I2C_FLAG_STOP    0x00040 // send STOP condition
+#define CG_I2C_FLAG_ALL_ACK 0x08000 // send ACK on all read bytes
+#define CG_I2C_FLAG_ALL_NAK 0x04000 // send NAK on all read bytes
+
+//***************************************************************************
+//
+// xCgebIOGetInfo
+//
+
+typedef struct {
+  unsigned int size;
+  unsigned short type;
+  unsigned short flags;
+  unsigned int outputPins;
+  unsigned int inputPins;
+  unsigned char *name;
+  } CGEB_IO_INFO;
+
+// IO Flags
+
+#define CGEB_IO_ALIGNED 0
+#define CGEB_IO_PACKED 1
+#define CGEB_IO_PACKED_WITH_NEXT 2
+
+//***************************************************************************
+
+#pragma pack(pop)
+
+//***************************************************************************
+
+#endif
diff --git a/drivers/cgosdrv/CgebFct.h b/drivers/cgosdrv/CgebFct.h
new file mode 100644
index 000000000000..c9ec4d3e6dbc
--- /dev/null
+++ b/drivers/cgosdrv/CgebFct.h
@@ -0,0 +1,56 @@
+/*---------------------------------------------------------------------------
+ *
+ * Copyright (c) 2015, congatec AG. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version 2 of 
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation, 
+ * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * The full text of the license may also be found at:        
+ * http://opensource.org/licenses/GPL-2.0
+ *
+ *---------------------------------------------------------------------------
+ */ 
+
+//***************************************************************************
+
+#ifndef _CGEBFCT_H_
+#define _CGEBFCT_H_
+
+//***************************************************************************
+
+unsigned int CgebInvoke(CGOS_DRV_CGEB *cgeb, CGEBFPS *fps, unsigned int size, unsigned int fct);
+unsigned int CgebInvokePlain(CGOS_DRV_CGEB *cgeb, unsigned int fct, unsigned int *pRes);
+unsigned int CgebInvokeVoid(CGOS_DRV_CGEB *cgeb, CGEBFPS *fps, unsigned int size);
+unsigned int CgebInvokePar(CGOS_DRV_CGEB *cgeb, unsigned int flags, unsigned int fct,
+    unsigned int unit, unsigned int par0, unsigned int par1,
+    unsigned int par2, unsigned int par3, unsigned int *pret0, unsigned int *pret1);
+unsigned int CgebInvokeIoctl(CGOS_DRV_CGEB *cgeb, unsigned int flags, unsigned int fct,
+  CGOS_DRV_VARS *cdv);
+unsigned int CgebInvokeRet(CGOS_DRV_CGEB *cgeb, unsigned int flags, unsigned int fct,
+    unsigned int *pRes);
+unsigned int CgebInvokeRetUnit(CGOS_DRV_CGEB *cgeb, unsigned int flags, unsigned int fct,
+    unsigned int unit, unsigned int *pRes);
+
+//***************************************************************************
+
+void CgebClose(CGOS_DRV_CGEB *cgeb);
+unsigned int CgebOpen(CGOS_DRV_VARS *cdv, unsigned char *base, unsigned int len);
+
+//***************************************************************************
+
+unsigned int CgebTransAddr(CGOS_DRV_CGEB *cgeb, unsigned int addr);
+
+//***************************************************************************
+
+#endif
diff --git a/drivers/cgosdrv/CgebSda.h b/drivers/cgosdrv/CgebSda.h
new file mode 100644
index 000000000000..639f95d5323e
--- /dev/null
+++ b/drivers/cgosdrv/CgebSda.h
@@ -0,0 +1,59 @@
+/*---------------------------------------------------------------------------
+ *
+ * Copyright (c) 2015, congatec AG. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version 2 of 
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation, 
+ * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * The full text of the license may also be found at:        
+ * http://opensource.org/licenses/GPL-2.0
+ *
+ *---------------------------------------------------------------------------
+ */ 
+
+//***************************************************************************
+
+#ifndef _CGEBSDA_H_
+#define _CGEBSDA_H_
+
+//***************************************************************************
+
+typedef struct {
+  unsigned char day;          // day (BCD 01h-31h)
+  unsigned char month;        // month(BCD 01h-12h)
+  unsigned char year;         // year(BCD 05h-99h)
+  } CGEB_DATE;
+
+typedef struct {
+  unsigned char cgTotalSize;         // total secure data area size in bytes
+  unsigned char cgCheckSize;         // size of the checksummed area
+  unsigned char cgChecksum;          // checksum correction byte
+  unsigned char cgSerialNumber[6];   // board serial number (BCD)
+  unsigned char cgPartNumber[16];    // board part number (ASCII)
+  unsigned char cgEanCode[7];        // board EAN-13 code (BCD)
+  unsigned char cgProductRevMaj;     // major product rev (ASCII)
+  unsigned char cgProductRevMin;     // minor product rev (ASCII)
+  CGEB_DATE cgMfgDate;               // date of manufacturing
+  CGEB_DATE cgRepairDate;            // date of last repair
+  unsigned char cgManufacturerId;    // manufacturer ID (hex)
+  unsigned char cgProjectId[4];      // project ID (ASCII)
+  unsigned char cgRepairCounter;     // repair counter (hex)
+  unsigned char cgSecureDataRes[13]; // spare
+  unsigned char cgBootCounter[3];    // board boot counter (hex)
+  unsigned short cgRunningTime;      // board running time in hours (hex)
+  } CGEB_SDA;
+
+//***************************************************************************
+
+#endif
diff --git a/drivers/cgosdrv/Cgos.h b/drivers/cgosdrv/Cgos.h
new file mode 100644
index 000000000000..56958fe49b9c
--- /dev/null
+++ b/drivers/cgosdrv/Cgos.h
@@ -0,0 +1,532 @@
+/*---------------------------------------------------------------------------
+ *
+ * Copyright (c) 2015, congatec AG. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the BSD 2-clause license which 
+ * accompanies this distribution. 
+ *
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the BSD 2-clause license for more details.
+ *
+ * The full text of the license may be found at:        
+ * http://opensource.org/licenses/BSD-2-Clause   
+ *
+ *---------------------------------------------------------------------------
+ */
+ 
+//***************************************************************************
+
+#ifndef _CGOS_H_
+#define _CGOS_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+//***************************************************************************
+
+#ifndef CGOSDLLAPI
+#define CGOSDLLAPI
+#endif
+
+#ifndef CGOSAPI
+#ifndef _WIN32
+#define CGOSAPI
+#elif defined(_MSC_VER) && (_MSC_VER >= 800)
+#define CGOSAPI __stdcall
+#else
+#define CGOSAPI pascal
+#endif
+#endif
+
+#define cgosret_bool CGOSDLLAPI unsigned int CGOSAPI
+#define cgosret_ulong CGOSDLLAPI unsigned int CGOSAPI
+
+//***************************************************************************
+
+#define CgosLibVersionMajor 1
+#define CgosLibVersionMinor 3
+#define CgosLibVersion (((((unsigned int)CgosLibVersionMajor)<<8)+CgosLibVersionMinor)<<16)
+
+//***************************************************************************
+
+typedef struct {
+  unsigned short wYear;
+  unsigned short wMonth;
+  unsigned short wDayOfWeek;
+  unsigned short wDay;
+  unsigned short wHour;
+  unsigned short wMinute;
+  unsigned short wSecond;
+  unsigned short wMilliseconds;
+  } CGOSTIME;
+
+//***************************************************************************
+
+#define CGOS_BOARD_MAX_LEN_ID_STRING 7
+#define CGOS_BOARD_MAX_SIZE_ID_STRING 16
+#define CGOS_BOARD_MAX_LEN_SERIAL_STRING 12
+#define CGOS_BOARD_MAX_SIZE_SERIAL_STRING 16
+#define CGOS_BOARD_MAX_LEN_PART_STRING 16
+#define CGOS_BOARD_MAX_SIZE_PART_STRING 20
+#define CGOS_BOARD_MAX_LEN_EAN_STRING 13
+#define CGOS_BOARD_MAX_SIZE_EAN_STRING 20
+
+typedef struct {
+  unsigned int dwSize;
+  unsigned int dwFlags;
+  char szReserved[CGOS_BOARD_MAX_SIZE_ID_STRING];
+  char szBoard[CGOS_BOARD_MAX_SIZE_ID_STRING];
+  char szBoardSub[CGOS_BOARD_MAX_SIZE_ID_STRING];
+  char szManufacturer[CGOS_BOARD_MAX_SIZE_ID_STRING];
+  CGOSTIME stManufacturingDate;
+  CGOSTIME stLastRepairDate;
+  char szSerialNumber[CGOS_BOARD_MAX_SIZE_SERIAL_STRING];
+  unsigned short wProductRevision;
+  unsigned short wSystemBiosRevision;
+  unsigned short wBiosInterfaceRevision;
+  unsigned short wBiosInterfaceBuildRevision;
+  unsigned int dwClasses;
+  unsigned int dwPrimaryClass;
+  unsigned int dwRepairCounter;
+  char szPartNumber[CGOS_BOARD_MAX_SIZE_PART_STRING];
+  char szEAN[CGOS_BOARD_MAX_SIZE_EAN_STRING];
+  unsigned int dwManufacturer;
+  } CGOSBOARDINFOA;
+
+typedef struct {
+  unsigned int dwSize;
+  unsigned int dwFlags;
+  wchar_t szReserved[CGOS_BOARD_MAX_SIZE_ID_STRING];
+  wchar_t szBoard[CGOS_BOARD_MAX_SIZE_ID_STRING];
+  wchar_t szBoardSub[CGOS_BOARD_MAX_SIZE_ID_STRING];
+  wchar_t szManufacturer[CGOS_BOARD_MAX_SIZE_ID_STRING];
+  CGOSTIME stManufacturingDate;
+  CGOSTIME stLastRepairDate;
+  wchar_t szSerialNumber[CGOS_BOARD_MAX_SIZE_SERIAL_STRING];
+  unsigned short wProductRevision;
+  unsigned short wSystemBiosRevision;
+  unsigned short wBiosInterfaceRevision;
+  unsigned short wBiosInterfaceBuildRevision;
+  unsigned int dwClasses;
+  unsigned int dwPrimaryClass;
+  unsigned int dwRepairCounter;
+  wchar_t szPartNumber[CGOS_BOARD_MAX_SIZE_PART_STRING];
+  wchar_t szEAN[CGOS_BOARD_MAX_SIZE_EAN_STRING];
+  unsigned int dwManufacturer;
+  } CGOSBOARDINFOW;
+
+#ifdef UNICODE
+#define CGOSBOARDINFO CGOSBOARDINFOW
+#define CGOSTCHAR wchar_t
+#else
+#define CGOSBOARDINFO CGOSBOARDINFOA
+#define CGOSTCHAR char
+#endif
+
+//***************************************************************************
+
+//
+// Board handle
+//
+
+typedef unsigned int HCGOS;
+
+//
+// Board Classes
+//
+
+#define CGOS_BOARD_CLASS_CPU 0x00000001
+#define CGOS_BOARD_CLASS_VGA 0x00000002
+#define CGOS_BOARD_CLASS_IO  0x00000004
+
+//
+// Board Open/Count Flags
+//
+
+#define CGOS_BOARD_OPEN_FLAGS_DEFAULT 0
+#define CGOS_BOARD_OPEN_FLAGS_PRIMARYONLY 1
+
+//
+// Max values for LCD settings
+//
+
+#define CGOS_VGA_CONTRAST_MAX 100
+#define CGOS_VGA_BACKLIGHT_MAX 100
+
+// CgosVgaGetInfo
+
+#define CGOS_VGA_TYPE_UNKNOWN  0x00000000
+#define CGOS_VGA_TYPE_CRT      0x00010000
+#define CGOS_VGA_TYPE_LCD      0x00020000
+#define CGOS_VGA_TYPE_LCD_DVO  0x00020001
+#define CGOS_VGA_TYPE_LCD_LVDS 0x00020002
+#define CGOS_VGA_TYPE_TV       0x00030000
+
+typedef struct {
+  unsigned int dwSize;
+  unsigned int dwType;
+  unsigned int dwFlags;
+  unsigned int dwNativeWidth;
+  unsigned int dwNativeHeight;
+  unsigned int dwRequestedWidth;
+  unsigned int dwRequestedHeight;
+  unsigned int dwRequestedBpp;
+  unsigned int dwMaxBacklight;
+  unsigned int dwMaxContrast;
+  } CGOSVGAINFO;
+
+//
+// Type identifiers for storage areas
+//
+
+#define CGOS_STORAGE_AREA_UNKNOWN   0
+#define CGOS_STORAGE_AREA_EEPROM    0x00010000
+#define CGOS_STORAGE_AREA_FLASH     0x00020000
+#define CGOS_STORAGE_AREA_CMOS      0x00030000
+#define CGOS_STORAGE_AREA_RAM       0x00040000
+
+//
+// I2C bus types returned by CgosI2CType()
+//
+
+#define CGOS_I2C_TYPE_UNKNOWN 0           // I2C bus for unknown or special purposes
+#define CGOS_I2C_TYPE_PRIMARY 0x00010000  // primary I2C bus
+#define CGOS_I2C_TYPE_SMB     0x00020000  // system management bus
+#define CGOS_I2C_TYPE_DDC     0x00030000  // I2C bus of the DDC interface
+
+//***************************************************************************
+
+//
+// Watchdog
+//
+
+#define CGOS_WDOG_MODE_REBOOT_PC    0
+#define CGOS_WDOG_MODE_RESTART_OS   1
+#define CGOS_WDOG_MODE_STAGED    0x80
+
+#define CGOS_WDOG_OPMODE_DISABLED      0
+#define CGOS_WDOG_OPMODE_ONETIME_TRIG  1
+#define CGOS_WDOG_OPMODE_SINGLE_EVENT  2
+#define CGOS_WDOG_OPMODE_EVENT_REPEAT  3
+
+#define CGOS_WDOG_EVENT_INT 0 // NMI/IRQ
+#define CGOS_WDOG_EVENT_SCI 1 // SMI/SCI
+#define CGOS_WDOG_EVENT_RST 2 // system reset
+#define CGOS_WDOG_EVENT_BTN 3 // power button
+
+#define CGOS_WDOG_EVENT_MAX_STAGES 3
+
+typedef struct {
+  unsigned int dwTimeout;
+  unsigned int dwEvent;
+  } CGOSWDSTAGE;
+
+typedef struct {
+  unsigned int dwSize;
+  unsigned int dwTimeout; // not used in staged mode
+  unsigned int dwDelay;
+  unsigned int dwMode;
+  // optional parameters for staged watchdog
+  unsigned int dwOpMode;
+  unsigned int dwStageCount;
+  CGOSWDSTAGE stStages[CGOS_WDOG_EVENT_MAX_STAGES];
+  } CGOSWDCONFIG;
+
+// Watch dog info
+
+#define CGOS_WDOG_TYPE_UNKNOWN  0
+#define CGOS_WDOG_TYPE_BC       0x00020000
+#define CGOS_WDOG_TYPE_CHIPSET  0x00030000
+
+typedef struct {
+  unsigned int dwSize;
+  unsigned int dwFlags;
+  unsigned int dwMinTimeout;
+  unsigned int dwMaxTimeout;
+  unsigned int dwMinDelay;
+  unsigned int dwMaxDelay;
+  unsigned int dwOpModes;         // supported operation mode mask (1<<opmode)
+  unsigned int dwMaxStageCount;
+  unsigned int dwEvents;          // supported event mask (1<<event)
+  unsigned int dwType;
+  } CGOSWDINFO;
+
+
+//***************************************************************************
+
+//
+// Temperature, fan, and voltage structures
+//
+
+// Temperature in units of 1/1000th degrees celcius
+
+typedef struct {
+  unsigned int dwSize;
+  unsigned int dwType;
+  unsigned int dwFlags;
+  unsigned int dwAlarm;
+  unsigned int dwRes;
+  unsigned int dwMin;
+  unsigned int dwMax;
+  unsigned int dwAlarmHi;
+  unsigned int dwHystHi;
+  unsigned int dwAlarmLo;
+  unsigned int dwHystLo;
+  } CGOSTEMPERATUREINFO;
+
+// Fan speed values in RPM (revolutions per minute)
+
+typedef struct {
+  unsigned int dwSize;
+  unsigned int dwType;
+  unsigned int dwFlags;
+  unsigned int dwAlarm;
+  unsigned int dwSpeedNom;
+  unsigned int dwMin;
+  unsigned int dwMax;
+  unsigned int dwAlarmHi;
+  unsigned int dwHystHi;
+  unsigned int dwAlarmLo;
+  unsigned int dwHystLo;
+  unsigned int dwOutMin;
+  unsigned int dwOutMax;
+  } CGOSFANINFO;
+
+// Voltage in units of 1/1000th volt
+
+typedef struct {
+  unsigned int dwSize;
+  unsigned int dwType;
+  unsigned int dwNom;
+  unsigned int dwFlags;
+  unsigned int dwAlarm;
+  unsigned int dwRes;
+  unsigned int dwMin;
+  unsigned int dwMax;
+  unsigned int dwAlarmHi;
+  unsigned int dwHystHi;
+  unsigned int dwAlarmLo;
+  unsigned int dwHystLo;
+  } CGOSVOLTAGEINFO;
+
+// Types
+
+#define CGOS_TEMP_CPU           0x00010000
+#define CGOS_TEMP_BOX           0x00020000
+#define CGOS_TEMP_ENV           0x00030000
+#define CGOS_TEMP_BOARD         0x00040000
+#define CGOS_TEMP_BACKPLANE     0x00050000
+#define CGOS_TEMP_CHIPSETS      0x00060000
+#define CGOS_TEMP_VIDEO         0x00070000
+#define CGOS_TEMP_OTHER         0x00080000
+#define CGOS_TEMP_TOPDIMM_ENV   0x00090000      // Top DIMM module environment temperature
+#define CGOS_TEMP_BOTDIMM_ENV   0x000A0000      // Bottom DIMM module environment temperature
+
+#define CGOS_FAN_CPU            0x00010000
+#define CGOS_FAN_BOX            0x00020000
+#define CGOS_FAN_ENV            0x00030000
+#define CGOS_FAN_CHIPSET        0x00040000
+#define CGOS_FAN_VIDEO          0x00050000
+#define CGOS_FAN_OTHER          0x00060000
+
+#define CGOS_VOLTAGE_CPU        0x00010000
+#define CGOS_VOLTAGE_DC         0x00020000
+#define CGOS_VOLTAGE_DC_STANDBY 0x00030000
+#define CGOS_VOLTAGE_BAT_CMOS   0x00040000
+#define CGOS_VOLTAGE_BAT_POWER  0x00050000
+#define CGOS_VOLTAGE_AC         0x00060000
+#define CGOS_VOLTAGE_OTHER      0x00070000
+#define CGOS_VOLTAGE_5V_S0      0x00080000
+#define CGOS_VOLTAGE_5V_S5      0x00090000
+#define CGOS_VOLTAGE_33V_S0     0x000A0000
+#define CGOS_VOLTAGE_33V_S5     0x000B0000
+#define CGOS_VOLTAGE_VCOREA     0x000C0000
+#define CGOS_VOLTAGE_VCOREB     0x000D0000
+#define CGOS_VOLTAGE_12V_S0     0x000E0000
+
+// Due to missing CGOS current sensor definitions 
+// the values of the existing current sensors are 
+// returned in CGOSVOLTAGEINFO as voltage drop of the 
+// respective input current on a 1 Ohm resistor.
+// This allows direct interpretation of this voltage 
+// as input current value in 1/1000th amperes.
+#define CGOS_VCURRENT_DC       	0x80020000
+#define CGOS_VCURRENT_5V_S0     0x80080000
+#define CGOS_VCURRENT_12V_S0    0x800E0000
+
+// Temperature, fan, voltage status flags
+
+#define CGOS_SENSOR_ACTIVE 0x01
+#define CGOS_SENSOR_ALARM 0x02
+#define CGOS_SENSOR_BROKEN 0x04
+#define CGOS_SENSOR_SHORTCIRCUIT 0x08
+
+//***************************************************************************
+
+//
+// Performance
+//
+
+#define CGOS_CPU_PERF_THROTTLING 1
+#define CGOS_CPU_PERF_FREQUENCY 2
+
+//***************************************************************************
+
+#ifndef NOCGOSAPI
+
+// Library
+
+cgosret_ulong CgosLibGetVersion(void);
+cgosret_bool CgosLibInitialize(void);
+cgosret_bool CgosLibUninitialize(void);
+cgosret_bool CgosLibIsAvailable(void);
+cgosret_bool CgosLibInstall(unsigned int install);
+cgosret_ulong CgosLibGetDrvVersion(void);
+cgosret_ulong CgosLibGetLastError(void); // 1.2
+cgosret_bool CgosLibSetLastErrorAddress(unsigned int *pErrNo); // 1.2
+
+// Generic board
+
+cgosret_bool CgosBoardClose(HCGOS hCgos);
+
+cgosret_ulong CgosBoardCount(unsigned int dwClass, unsigned int dwFlags);
+cgosret_bool CgosBoardOpen(unsigned int dwClass, unsigned int dwNum, unsigned int dwFlags, HCGOS *phCgos);
+cgosret_bool CgosBoardOpenByNameA(const char *pszName, HCGOS *phCgos);
+cgosret_bool CgosBoardGetNameA(HCGOS hCgos, char *pszName, unsigned int dwSize);
+cgosret_bool CgosBoardGetInfoA(HCGOS hCgos, CGOSBOARDINFOA *pBoardInfo);
+
+cgosret_bool CgosBoardGetBootCounter(HCGOS hCgos, unsigned int *pdwCount);
+cgosret_bool CgosBoardGetRunningTimeMeter(HCGOS hCgos, unsigned int *pdwCount);
+
+// VGA (LCD)
+
+cgosret_ulong CgosVgaCount(HCGOS hCgos);
+cgosret_bool CgosVgaGetContrast(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwSetting);
+cgosret_bool CgosVgaSetContrast(HCGOS hCgos, unsigned int dwUnit, unsigned int dwSetting);
+cgosret_bool CgosVgaGetContrastEnable(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwSetting);
+cgosret_bool CgosVgaSetContrastEnable(HCGOS hCgos, unsigned int dwUnit, unsigned int dwSetting);
+cgosret_bool CgosVgaGetBacklight(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwSetting);
+cgosret_bool CgosVgaSetBacklight(HCGOS hCgos, unsigned int dwUnit, unsigned int dwSetting);
+cgosret_bool CgosVgaGetBacklightEnable(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwSetting);
+cgosret_bool CgosVgaSetBacklightEnable(HCGOS hCgos, unsigned int dwUnit, unsigned int dwSetting);
+cgosret_bool CgosVgaGetInfo(HCGOS hCgos, unsigned int dwUnit, CGOSVGAINFO *pInfo);
+
+// Storage Areas
+
+cgosret_ulong CgosStorageAreaCount(HCGOS hCgos, unsigned int dwUnit);
+cgosret_ulong CgosStorageAreaType(HCGOS hCgos, unsigned int dwUnit);
+cgosret_ulong CgosStorageAreaSize(HCGOS hCgos, unsigned int dwUnit);
+cgosret_ulong CgosStorageAreaBlockSize(HCGOS hCgos, unsigned int dwUnit);
+cgosret_bool CgosStorageAreaRead(HCGOS hCgos, unsigned int dwUnit, unsigned int dwOffset, unsigned char *pBytes, unsigned int dwLen);
+cgosret_bool CgosStorageAreaWrite(HCGOS hCgos, unsigned int dwUnit, unsigned int dwOffset, unsigned char *pBytes, unsigned int dwLen);
+cgosret_bool CgosStorageAreaErase(HCGOS hCgos, unsigned int dwUnit, unsigned int dwOffset, unsigned int dwLen);
+cgosret_bool CgosStorageAreaEraseStatus(HCGOS hCgos, unsigned int dwUnit, unsigned int dwOffset, unsigned int dwLen, unsigned int *lpStatus);
+cgosret_bool CgosStorageAreaLock(HCGOS hCgos, unsigned int dwUnit, unsigned int dwFlags, unsigned char *pBytes, unsigned int dwLen); // 1.2
+cgosret_bool CgosStorageAreaUnlock(HCGOS hCgos, unsigned int dwUnit, unsigned int dwFlags, unsigned char *pBytes, unsigned int dwLen); // 1.2
+cgosret_bool CgosStorageAreaIsLocked(HCGOS hCgos, unsigned int dwUnit, unsigned int dwFlags); // 1.2
+
+// I2C Bus
+
+cgosret_ulong CgosI2CCount(HCGOS hCgos);
+cgosret_ulong CgosI2CType(HCGOS hCgos, unsigned int dwUnit);
+cgosret_bool CgosI2CIsAvailable(HCGOS hCgos, unsigned int dwUnit);
+cgosret_bool CgosI2CRead(HCGOS hCgos, unsigned int dwUnit, unsigned char bAddr, unsigned char *pBytes, unsigned int dwLen);
+cgosret_bool CgosI2CWrite(HCGOS hCgos, unsigned int dwUnit, unsigned char bAddr, unsigned char *pBytes, unsigned int dwLen);
+
+cgosret_bool CgosI2CReadRegister(HCGOS hCgos, unsigned int dwUnit, unsigned char bAddr, unsigned short wReg, unsigned char *pDataByte);
+cgosret_bool CgosI2CWriteRegister(HCGOS hCgos, unsigned int dwUnit, unsigned char bAddr, unsigned short wReg, unsigned char bData);
+
+cgosret_bool CgosI2CWriteReadCombined(HCGOS hCgos, unsigned int dwUnit, unsigned char bAddr, unsigned char *pBytesWrite,
+  unsigned int dwLenWrite, unsigned char *pBytesRead, unsigned int dwLenRead);
+
+cgosret_bool CgosI2CGetMaxFrequency(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwSetting); // 1.3
+cgosret_bool CgosI2CGetFrequency(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwSetting); // 1.3
+cgosret_bool CgosI2CSetFrequency(HCGOS hCgos, unsigned int dwUnit, unsigned int dwSetting); // 1.3
+
+// General purpose IO
+
+cgosret_ulong CgosIOCount(HCGOS hCgos);
+cgosret_bool CgosIOIsAvailable(HCGOS hCgos, unsigned int dwUnit);
+cgosret_bool CgosIORead(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwData);
+cgosret_bool CgosIOWrite(HCGOS hCgos, unsigned int dwUnit, unsigned int dwData);
+cgosret_bool CgosIOXorAndXor(HCGOS hCgos, unsigned int dwUnit, unsigned int dwXorMask1, unsigned int dwAndMask, unsigned int dwXorMask2);
+cgosret_bool CgosIOGetDirection(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwData);
+cgosret_bool CgosIOSetDirection(HCGOS hCgos, unsigned int dwUnit, unsigned int dwData);
+cgosret_bool CgosIOGetDirectionCaps(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwInputs, unsigned int *pdwOutputs);
+cgosret_bool CgosIOGetNameA(HCGOS hCgos, unsigned int dwUnit, char *pszName, unsigned int dwSize);
+
+// Watchdog
+
+cgosret_ulong CgosWDogCount(HCGOS hCgos);
+cgosret_bool CgosWDogIsAvailable(HCGOS hCgos, unsigned int dwUnit);
+cgosret_bool CgosWDogTrigger(HCGOS hCgos, unsigned int dwUnit);
+cgosret_bool CgosWDogGetConfigStruct(HCGOS hCgos, unsigned int dwUnit, CGOSWDCONFIG *pConfig);
+cgosret_bool CgosWDogSetConfigStruct(HCGOS hCgos, unsigned int dwUnit, CGOSWDCONFIG *pConfig);
+cgosret_bool CgosWDogSetConfig(HCGOS hCgos, unsigned int dwUnit, unsigned int timeout, unsigned int delay, unsigned int mode);
+cgosret_bool CgosWDogDisable(HCGOS hCgos, unsigned int dwUnit);
+cgosret_bool CgosWDogGetInfo(HCGOS hCgos, unsigned int dwUnit, CGOSWDINFO *pInfo);
+
+// CPU Performance
+
+cgosret_bool CgosPerformanceGetCurrent(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwSetting);
+cgosret_bool CgosPerformanceSetCurrent(HCGOS hCgos, unsigned int dwUnit, unsigned int dwSetting);
+cgosret_bool CgosPerformanceGetPolicyCaps(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwSetting);
+cgosret_bool CgosPerformanceGetPolicy(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwSetting);
+cgosret_bool CgosPerformanceSetPolicy(HCGOS hCgos, unsigned int dwUnit, unsigned int dwSetting);
+
+// Temperature
+
+cgosret_ulong CgosTemperatureCount(HCGOS hCgos);
+cgosret_bool CgosTemperatureGetInfo(HCGOS hCgos, unsigned int dwUnit, CGOSTEMPERATUREINFO *pInfo);
+cgosret_bool CgosTemperatureGetCurrent(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwSetting, unsigned int *pdwStatus);
+cgosret_bool CgosTemperatureSetLimits(HCGOS hCgos, unsigned int dwUnit, CGOSTEMPERATUREINFO *pInfo);
+
+// Fan
+
+cgosret_ulong CgosFanCount(HCGOS hCgos);
+cgosret_bool CgosFanGetInfo(HCGOS hCgos, unsigned int dwUnit, CGOSFANINFO *pInfo);
+cgosret_bool CgosFanGetCurrent(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwSetting, unsigned int *pdwStatus);
+cgosret_bool CgosFanSetLimits(HCGOS hCgos, unsigned int dwUnit, CGOSFANINFO *pInfo);
+
+// Voltage
+
+cgosret_ulong CgosVoltageCount(HCGOS hCgos);
+cgosret_bool CgosVoltageGetInfo(HCGOS hCgos, unsigned int dwUnit, CGOSVOLTAGEINFO *pInfo);
+cgosret_bool CgosVoltageGetCurrent(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwSetting, unsigned int *pdwStatus);
+cgosret_bool CgosVoltageSetLimits(HCGOS hCgos, unsigned int dwUnit, CGOSVOLTAGEINFO *pInfo);
+
+//***************************************************************************
+
+// Unicode
+
+cgosret_bool CgosBoardOpenByNameW(const wchar_t *pszName, HCGOS *phCgos);
+cgosret_bool CgosBoardGetNameW(HCGOS hCgos, wchar_t *pszName, unsigned int dwSize);
+cgosret_bool CgosBoardGetInfoW(HCGOS hCgos, CGOSBOARDINFOW *pBoardInfo);
+cgosret_bool CgosIOGetNameW(HCGOS hCgos, unsigned int dwUnit, wchar_t *pszName, unsigned int dwSize);
+
+#ifdef UNICODE
+#define CgosBoardOpenByName CgosBoardOpenByNameW
+#define CgosBoardGetName CgosBoardGetNameW
+#define CgosBoardGetInfo CgosBoardGetInfoW
+#define CgosIOGetName CgosIOGetNameW
+#else
+#define CgosBoardOpenByName CgosBoardOpenByNameA
+#define CgosBoardGetName CgosBoardGetNameA
+#define CgosBoardGetInfo CgosBoardGetInfoA
+#define CgosIOGetName CgosIOGetNameA
+#endif
+
+#endif
+
+//***************************************************************************
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _CGOS_H_
+
diff --git a/drivers/cgosdrv/CgosBld.h b/drivers/cgosdrv/CgosBld.h
new file mode 100644
index 000000000000..29477d0d62c8
--- /dev/null
+++ b/drivers/cgosdrv/CgosBld.h
@@ -0,0 +1,3 @@
+#ifndef CGOS_BUILD_NUMBER
+#define CGOS_BUILD_NUMBER 21
+#endif
diff --git a/drivers/cgosdrv/CgosDef.h b/drivers/cgosdrv/CgosDef.h
new file mode 100644
index 000000000000..8c22e7b732c2
--- /dev/null
+++ b/drivers/cgosdrv/CgosDef.h
@@ -0,0 +1,54 @@
+/*---------------------------------------------------------------------------
+ *
+ * Copyright (c) 2015, congatec AG. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the BSD 2-clause license which 
+ * accompanies this distribution. 
+ *
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the BSD 2-clause license for more details.
+ *
+ * The full text of the license may be found at:        
+ * http://opensource.org/licenses/BSD-2-Clause   
+ *
+ *---------------------------------------------------------------------------
+ */
+ 
+//***************************************************************************
+
+#ifndef _CGOSDEF_H_
+#define _CGOSDEF_H_
+
+//***************************************************************************
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef NULL
+#define NULL ((void *)0)
+#endif
+
+//***************************************************************************
+
+// just to have an option
+#ifdef DEF_WCHAR_T
+#define wchar_t short
+#endif
+
+//***************************************************************************
+
+#ifndef dbpf
+#define dbpf(s)
+#endif
+
+//***************************************************************************
+
+#endif
diff --git a/drivers/cgosdrv/CgosDrv.c b/drivers/cgosdrv/CgosDrv.c
new file mode 100644
index 000000000000..eeb074d848f2
--- /dev/null
+++ b/drivers/cgosdrv/CgosDrv.c
@@ -0,0 +1,1094 @@
+/*---------------------------------------------------------------------------
+ *
+ * Copyright (c) 2015, congatec AG. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version 2 of 
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation, 
+ * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * The full text of the license may also be found at:        
+ * http://opensource.org/licenses/GPL-2.0
+ *
+ *---------------------------------------------------------------------------
+ */ 
+
+//***************************************************************************
+
+#include "CgosDrv.h"
+#include "CgosBld.h"
+
+//***************************************************************************
+
+#define CGOS_DRIVER_MINOR 2
+
+//***************************************************************************
+
+#define CGOS_SUCCESS 0
+#define CGOS_ERROR -1
+#define CGOS_INVALID_PARAMETER -2
+#define CGOS_NOT_IMPLEMENTED -3
+
+#ifndef CGOS_INVALID_HANDLE
+#define CGOS_INVALID_HANDLE ((void *)-1)
+#endif
+
+//***************************************************************************
+
+#define INVALID_UNIT ((unsigned int)-1)
+
+//***************************************************************************
+
+unsigned char BCD(unsigned char b)
+  {
+  if (b==0xff) return 0;
+  return (b>>4)*10+(b&0xf);
+  }
+
+void BCDtoStr(char *s, unsigned char *bcd, unsigned int cnt)
+  {
+  while (cnt--) {
+    unsigned char b=*bcd++;
+    *s++=((b>>4)&0xf)+'0';
+    *s++=((b)&0xf)+'0';
+    }
+  }
+
+void ConvertDate(CGOSTIME *cgostime, CGEB_DATE *cgebdate)
+  {
+  cgostime->wYear=BCD(cgebdate->year);
+  if (cgostime->wYear) cgostime->wYear+=2000;
+  cgostime->wMonth=BCD(cgebdate->month);
+  cgostime->wDay=BCD(cgebdate->day);
+  }
+
+unsigned short ConvertPID(unsigned char c)
+  {
+  if (c>=127 || c<'0') return '0';
+  return c;
+  }
+
+void ConvertInfo(CGOSBOARDINFOA *info, CGEB_SDA *sda)
+  {
+  if (!sda->cgTotalSize || sda->cgTotalSize==0xff) return; // data invalid
+
+  OsaMemCpy(info->szBoardSub,sda->cgProjectId,4);
+  ConvertDate(&info->stManufacturingDate,&sda->cgMfgDate);
+  ConvertDate(&info->stLastRepairDate,&sda->cgRepairDate);
+  BCDtoStr(info->szSerialNumber,sda->cgSerialNumber,sizeof(sda->cgSerialNumber));
+  info->wProductRevision=(ConvertPID(sda->cgProductRevMaj)<<8)|(ConvertPID(sda->cgProductRevMin));
+  {
+  unsigned char *s=sda->cgPartNumber;
+  unsigned int l=sizeof(sda->cgPartNumber);
+  while (l && !*s) s++, l--;
+  OsaMemCpy(info->szPartNumber,s,l);
+  info->szPartNumber[l]=0;
+  }
+  BCDtoStr(info->szEAN,sda->cgEanCode,sizeof(sda->cgEanCode));
+  info->dwManufacturer=sda->cgManufacturerId;
+  }
+
+
+unsigned int StoCountType(CGOS_DRV_BOARD *brd, unsigned int type)
+  {
+  unsigned int i,cnt=0;
+  if (!type) {
+    for (i=0; i<brd->stoCount; i++)
+      if (!(brd->sto[i].info.type&0xC0000000)) cnt++;
+    }
+  else {
+    for (i=0; i<brd->stoCount; i++)
+      if (type==brd->sto[i].info.type) cnt++;
+    }
+  return cnt;
+  }
+
+unsigned int StoFindTypeInd(CGOS_DRV_BOARD *brd, unsigned int type, unsigned int ind, unsigned int mask)
+  {
+  unsigned int i;
+  if (!type) {
+    for (i=0; i<brd->stoCount; i++)
+      if (!(brd->sto[i].info.type&0xC0000000) && !ind--) return i;
+    }
+  else {
+    for (i=0; i<brd->stoCount; i++)
+      if (type==(brd->sto[i].info.type&mask) && !ind--) return i;
+    }
+  return (unsigned int)-1;
+  }
+
+unsigned int StoFindType(CGOS_DRV_BOARD *brd, unsigned int type)
+  {
+  return StoFindTypeInd(brd,type&~0xff,type&0xff,~0xff);
+  }
+
+unsigned int StoRead(CGOS_DRV_BOARD *brd,
+    unsigned int unit,
+    unsigned int offset,
+    unsigned char *pBytesRead, unsigned int dwLenRead,
+    unsigned int *pdwBytesRead)
+  {
+  CGEBFPS fps;
+  unsigned int ret;
+  OsaMemSet(&fps,0,sizeof(fps));
+  fps.unit=unit;
+  fps.pars[0]=offset;
+  fps.pars[1]=dwLenRead;
+  fps.optr=pBytesRead;
+  ret=CgebInvoke(&brd->cgeb,&fps,sizeof(fps),xCgebStorageAreaRead);
+  if (pdwBytesRead) *pdwBytesRead=fps.rets[0];
+  return ret;
+  }
+
+
+unsigned int SdaReadToInfo(CGOS_DRV_BOARD *brd)
+  {
+  CGEB_SDA sda;
+  unsigned int unit=StoFindType(brd,CGOS_STORAGE_AREA_SDA);
+  unsigned int ret;
+  ret=StoRead(brd,unit,0,(unsigned char *)&sda,sizeof(sda),NULL);
+  if (!ret) return ret;
+  ConvertInfo(&brd->info,&sda);
+  return ret;
+  }
+
+//***************************************************************************
+
+unsigned int I2CFindTypeInd(CGOS_DRV_BOARD *brd, unsigned int type, unsigned int ind)
+  {
+  unsigned int i;
+  CGEB_I2C_INFO *info;
+  if (!type) return ind;
+  for (i=0; i<brd->i2cCount; i++) {
+    if (!CgebInvokeRetUnit(&brd->cgeb,4,xCgebI2CGetInfo,i,(void *)&info) || !info) break;
+    if (type==(info->type<<16) && !ind--) return i;
+    }
+  return (unsigned int)-1;
+  }
+
+unsigned int I2CFindType(CGOS_DRV_BOARD *brd, unsigned int type)
+  {
+  return I2CFindTypeInd(brd,type&~0xffff,type&0xffff);
+  }
+
+//***************************************************************************
+
+//
+// I2C transfer
+//
+
+unsigned int I2CTransfer(CGOS_DRV_VARS *cdv,
+    unsigned int unit, unsigned int flags,
+    unsigned char *pBytesWrite, unsigned int dwLenWrite,
+    unsigned char *pBytesRead, unsigned int dwLenRead,
+    unsigned int *pdwBytesRead, unsigned int *pdwStatus)
+  {
+  CGEBFPS fps;
+  unsigned int ret;
+  OsaMemSet(&fps,0,sizeof(fps));
+  fps.unit=unit;
+  fps.pars[0]=dwLenWrite;
+  fps.pars[1]=dwLenRead;
+  fps.pars[2]=flags;
+  fps.iptr=pBytesWrite;
+  fps.optr=pBytesRead;
+  ret=CgebInvoke(&cdv->brd->cgeb,&fps,sizeof(fps),xCgebI2CTransfer);
+  if (pdwBytesRead) *pdwBytesRead=fps.rets[0];
+  if (pdwStatus) *pdwStatus=fps.status;
+//  return ret?CGOS_SUCCESS:CGOS_ERROR;
+  return ret;
+  }
+
+//***************************************************************************
+
+unsigned int zCgosSuccess(CGOS_DRV_VARS *cdv)
+  {
+  cdv->cout->rets[0]=0;
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosDrvGetVersion(CGOS_DRV_VARS *cdv)
+  {
+  cdv->cout->rets[0]=(((((unsigned int)CGOS_DRIVER_MAJOR)<<8)|CGOS_DRIVER_MINOR)<<16)|CGOS_BUILD_NUMBER;
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosBoardClose(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosBoardCount(CGOS_DRV_VARS *cdv)
+  {
+  enum { dwClass,dwFlags };
+  unsigned int i,cnt=0;
+  if (!cdv->cin->pars[dwClass]) // no preferred class
+    cnt=cdv->boardCount; // just return the total number of boards
+  else { // filter requested classes
+    unsigned int mask=(unsigned int)-!(cdv->cin->pars[dwFlags]&CGOS_BOARD_OPEN_FLAGS_PRIMARYONLY); // flags
+    for (i=0; i<cdv->boardCount; i++)
+      if ((cdv->boards[i].info.dwPrimaryClass|(cdv->boards[i].info.dwClasses&mask))&cdv->cin->pars[dwClass])
+        cnt++;
+    }
+  cdv->cout->rets[0]=cnt;
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosBoardOpen(CGOS_DRV_VARS *cdv)
+  {
+  enum { dwClass,dwFlags };
+  unsigned int i,cnt=cdv->cin->type; // number within filtered classes
+  if (!cdv->cin->pars[dwClass]) {  // no preferred class
+    if (cnt>=cdv->boardCount) return CGOS_ERROR;
+    cdv->cout->rets[0]=cnt+1; // hCgos is the board number + 1
+    return CGOS_SUCCESS;
+    }
+  else { // filter requested classes
+    unsigned int mask=(unsigned int)-!(cdv->cin->pars[dwFlags]&CGOS_BOARD_OPEN_FLAGS_PRIMARYONLY);
+    for (i=0; i<cdv->boardCount; i++)
+      if ((cdv->boards[i].info.dwPrimaryClass|(cdv->boards[i].info.dwClasses&mask))&cdv->cin->pars[dwClass])
+        if (!cnt--) {
+          cdv->cout->rets[0]=i+1; // hCgos is the board number + 1
+          return CGOS_SUCCESS;
+          }
+    }
+  return CGOS_ERROR;
+  }
+
+unsigned int zCgosBoardOpenByNameA(CGOS_DRV_VARS *cdv)
+  {
+  unsigned int i;
+  if (cdv->lin<4) return CGOS_ERROR; // REVIEW
+  for (i=0; i<cdv->boardCount; i++)
+    // REVIEW this assumes that board names are always 4 chars, we don't have a strcmp yet!
+    if (*(unsigned int *)cdv->boards[i].info.szBoard==*(unsigned int *)cdv->pin) {
+      cdv->cout->rets[0]=i+1; // hCgos is the board number + 1
+      return CGOS_SUCCESS;
+      }
+  return CGOS_ERROR;
+  }
+
+unsigned int zCgosBoardGetNameA(CGOS_DRV_VARS *cdv)
+  {
+  // should be a OsaStrNCpy
+  OsaMemCpy(cdv->pout,cdv->brd->info.szBoard,cdv->lout);
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosBoardGetInfoA(CGOS_DRV_VARS *cdv)
+  {
+  OsaMemCpy(cdv->pout,&cdv->brd->info,cdv->lout);
+  return CGOS_SUCCESS;
+  }
+/*
+unsigned int zCgosBoardGetBootCounter(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosBoardGetRunningTimeMeter(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosBoardGetOption(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosBoardSetOption(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosBoardGetBootErrorLog(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosVgaGetContrast(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosVgaSetContrast(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosVgaGetContrastEnable(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosVgaSetContrastEnable(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosVgaGetBacklight(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosVgaSetBacklight(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosVgaGetBacklightEnable(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosVgaSetBacklightEnable(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosVgaEndDarkBoot(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+*/
+
+unsigned int zCgosStorageAreaCount(CGOS_DRV_VARS *cdv)
+  {
+  cdv->cout->rets[0]=StoCountType(cdv->brd,cdv->cin->type);
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosStorageAreaType(CGOS_DRV_VARS *cdv)
+  {
+  cdv->cout->rets[0]=cdv->sto->info.type&0x00ff0000;
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosStorageAreaSize(CGOS_DRV_VARS *cdv)
+  {
+  cdv->cout->rets[0]=cdv->sto->info.areaSize;
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosStorageAreaBlockSize(CGOS_DRV_VARS *cdv)
+  {
+  cdv->cout->rets[0]=cdv->sto->info.blockSize;
+  return CGOS_SUCCESS;
+  }
+
+/*
+unsigned int zCgosStorageAreaRead(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosStorageAreaWrite(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosStorageAreaErase(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosStorageAreaEraseStatus(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+*/
+unsigned int zCgosI2CCount(CGOS_DRV_VARS *cdv)
+  {
+  cdv->cout->rets[0]=cdv->brd->i2cCount;
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosI2CType(CGOS_DRV_VARS *cdv)
+  {
+  CGEB_I2C_INFO *info;
+  if (!CgebInvokeRetUnit(&cdv->brd->cgeb,4,xCgebI2CGetInfo,cdv->unit,(void *)&info) || !info) return CGOS_ERROR;
+  cdv->cout->rets[0]=info->type<<16;
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosI2CIsAvailable(CGOS_DRV_VARS *cdv)
+  {
+  // TODO: we need to walk thru the types here
+  cdv->cout->rets[0]=cdv->unit<cdv->brd->i2cCount;
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosI2CRead(CGOS_DRV_VARS *cdv)
+  {
+  unsigned int stat;
+  if (!I2CTransfer(cdv,cdv->cin->type,CG_I2C_FLAG_START|CG_I2C_FLAG_STOP,
+    (unsigned char *)&cdv->cin->pars[0],1,cdv->pout,cdv->lout,&cdv->retcnt,&stat)) return stat;
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosI2CWrite(CGOS_DRV_VARS *cdv)
+  {
+  unsigned int stat;
+  if (!I2CTransfer(cdv,cdv->cin->type,CG_I2C_FLAG_START,
+      (unsigned char *)&cdv->cin->pars[0],1,NULL,0,NULL,&stat)) return stat;
+  if (!I2CTransfer(cdv,cdv->cin->type,CG_I2C_FLAG_STOP,
+      (unsigned char *)(cdv->cin+1),cdv->lin,NULL,0,NULL,&stat)) return stat;
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosI2CReadRegister(CGOS_DRV_VARS *cdv)
+  {
+  unsigned int stat;
+  enum { bAddr,wReg };
+  unsigned char b[2];
+  b[0]=(unsigned char)(cdv->cin->pars[bAddr]|((cdv->cin->pars[wReg]>>7)&0x0e))&0xfe; // addr
+  b[1]=(unsigned char)cdv->cin->pars[wReg]; // register
+  if (!I2CTransfer(cdv,cdv->cin->type,CG_I2C_FLAG_START,
+      b,2,NULL,0,NULL,&stat)) return stat;
+  // read value
+  b[0]|=1;
+  if (!I2CTransfer(cdv,cdv->cin->type,CG_I2C_FLAG_START|CG_I2C_FLAG_STOP,
+    b,1,b+1,1,NULL,&stat)) return stat;
+  cdv->cout->rets[0]=b[1];
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosI2CWriteRegister(CGOS_DRV_VARS *cdv)
+  {
+  unsigned int stat;
+  enum { bAddr,wReg,bData };
+  unsigned char b[3];
+  b[0]=(unsigned char)(cdv->cin->pars[bAddr]|((cdv->cin->pars[wReg]>>7)&0x0e))&0xfe; // addr
+  b[1]=(unsigned char)cdv->cin->pars[wReg]; // register
+  b[2]=(unsigned char)cdv->cin->pars[bData]; // value
+  if (!I2CTransfer(cdv,cdv->cin->type,CG_I2C_FLAG_START|CG_I2C_FLAG_STOP,
+      b,3,NULL,0,NULL,&stat)) return stat;
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosI2CWriteReadCombined(CGOS_DRV_VARS *cdv)
+  {
+  unsigned int stat;
+  unsigned char addr=(unsigned char)cdv->cin->pars[0]&0xfe; // addr
+  if (!I2CTransfer(cdv,cdv->cin->type,CG_I2C_FLAG_START,
+      &addr,1,NULL,0,NULL,&stat)) return stat;
+  if (!I2CTransfer(cdv,cdv->cin->type,0,
+      (unsigned char *)(cdv->cin+1),cdv->lin,NULL,0,NULL,&stat)) return stat;
+  // read part
+  addr|=1;
+  if (!I2CTransfer(cdv,cdv->cin->type,CG_I2C_FLAG_START|CG_I2C_FLAG_STOP,
+    &addr,1,cdv->pout,cdv->lout,&cdv->retcnt,&stat)) return stat;
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosI2CGetMaxFrequency(CGOS_DRV_VARS *cdv)
+  {
+  CGEB_I2C_INFO *info;
+  if (!CgebInvokeRetUnit(&cdv->brd->cgeb,4,xCgebI2CGetInfo,cdv->unit,(void *)&info) || !info) return CGOS_ERROR;
+  cdv->cout->rets[0]=info->maxFrequency;
+  return CGOS_SUCCESS;
+  }
+
+
+unsigned int IoGetInfo(CGOS_DRV_VARS *cdv, CGEB_IO_INFO **info)
+  {
+  if (!CgebInvokeRetUnit(&cdv->brd->cgeb,4,xCgebIOGetInfo,cdv->unit,(void *)info) || !*info) return 0;
+  return 1;
+  }
+
+/*
+
+unsigned int zCgosIOCount(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+*/
+
+unsigned int zCgosIOIsAvailable(CGOS_DRV_VARS *cdv)
+  {
+  unsigned int dw=0;
+  CgebInvokePlain(&cdv->brd->cgeb,xCgebIOCount,&dw);
+  cdv->cout->rets[0]=cdv->unit<dw;
+  return CGOS_SUCCESS;
+  }
+
+/*
+unsigned int zCgosIORead(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosIOWrite(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+*/
+
+unsigned int zCgosIOXorAndXor(CGOS_DRV_VARS *cdv)
+  {
+  unsigned int dw;
+  if (!CgebInvokeRetUnit(&cdv->brd->cgeb,1,xCgebIORead,cdv->unit,&dw)) return CGOS_ERROR;
+  dw^=cdv->cin->pars[0];
+  dw&=cdv->cin->pars[1];
+  dw^=cdv->cin->pars[2];
+  if (!CgebInvokePar(&cdv->brd->cgeb,0,xCgebIOWrite,cdv->unit,dw,0,0,0,NULL,NULL)) return CGOS_ERROR;
+  return CGOS_SUCCESS;
+  }
+
+/*
+unsigned int zCgosIOGetDirection(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosIOSetDirection(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+*/
+
+unsigned int zCgosIOGetDirectionCaps(CGOS_DRV_VARS *cdv)
+  {
+  CGEB_IO_INFO *info;
+  if (!IoGetInfo(cdv,&info)) return CGOS_ERROR;
+  cdv->cout->rets[0]=info->inputPins;
+  cdv->cout->rets[1]=info->outputPins;
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosIOGetNameA(CGOS_DRV_VARS *cdv)
+  {
+  CGEB_IO_INFO *info;
+  if (!IoGetInfo(cdv,&info)) return CGOS_ERROR;
+  // should be a OsaStrNCpy
+  OsaMemCpy(cdv->pout,info->name?info->name:(unsigned char *)"",cdv->lout);
+  return CGOS_SUCCESS;
+  }
+
+/*
+unsigned int zCgosWDogCount(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+*/
+
+unsigned int zCgosWDogIsAvailable(CGOS_DRV_VARS *cdv)
+  {
+  cdv->cout->rets[0]=cdv->unit<cdv->brd->wdogCount;
+  return CGOS_SUCCESS;
+  }
+
+/*
+unsigned int zCgosWDogTrigger(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosWDogGetTriggerCount(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosWDogSetTriggerCount(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosWDogGetConfigStruct(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosWDogSetConfigStruct(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+*/
+
+unsigned int WdSet(CGOS_DRV_VARS *cdv, CGOSWDCONFIG *wdi)
+  {
+  CGEBFPS fps;
+  OsaMemSet(&fps,0,sizeof(fps));
+  fps.unit=cdv->cin->type;
+  fps.iptr=wdi;
+  return CgebInvoke(&cdv->brd->cgeb,&fps,sizeof(fps),xCgebWDogSetConfig);
+  }
+
+unsigned int zCgosWDogSetConfig(CGOS_DRV_VARS *cdv)
+  {
+  enum { dwTimeout, dwDelay, dwMode };
+  CGOSWDCONFIG wdi;
+  OsaMemSet(&wdi,0,sizeof(wdi));
+  wdi.dwSize=sizeof(wdi);
+  wdi.dwTimeout=cdv->cin->pars[dwTimeout];
+  wdi.dwDelay=cdv->cin->pars[dwDelay];
+  if (!wdi.dwTimeout && !wdi.dwDelay) {
+    wdi.dwMode=CGOS_WDOG_MODE_STAGED;
+    wdi.dwOpMode=CGOS_WDOG_OPMODE_DISABLED;
+    }
+  else {
+    wdi.dwMode=cdv->cin->pars[dwMode]; // |CGOS_WDOG_MODE_STAGED;
+    wdi.dwOpMode=CGOS_WDOG_OPMODE_SINGLE_EVENT;
+    wdi.dwStageCount=1;
+    wdi.stStages[0].dwEvent=(wdi.dwMode&CGOS_WDOG_MODE_RESTART_OS)?CGOS_WDOG_EVENT_INT:CGOS_WDOG_EVENT_RST;
+    wdi.stStages[0].dwTimeout=cdv->cin->pars[dwTimeout];
+    }
+  return WdSet(cdv,&wdi)?CGOS_SUCCESS:CGOS_ERROR;
+  }
+
+unsigned int zCgosWDogDisable(CGOS_DRV_VARS *cdv)
+  {
+  CGOSWDCONFIG wdi;
+  OsaMemSet(&wdi,0,sizeof(wdi));
+  wdi.dwSize=sizeof(wdi);
+  wdi.dwMode=CGOS_WDOG_MODE_STAGED;
+  wdi.dwOpMode=CGOS_WDOG_OPMODE_DISABLED;
+  return WdSet(cdv,&wdi)?CGOS_SUCCESS:CGOS_ERROR;
+  }
+
+/*
+unsigned int zCgosPerformanceGetCurrent(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosPerformanceSetCurrent(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosPerformanceGetPolicyCaps(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosPerformanceGetPolicy(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosPerformanceSetPolicy(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosTemperatureCount(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosTemperatureGetInfo(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosTemperatureGetCurrent(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosTemperatureSetLimits(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosFanCount(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosFanGetInfo(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosFanGetCurrent(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosFanSetLimits(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosVoltageCount(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosVoltageGetInfo(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosVoltageGetCurrent(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosVoltageSetLimits(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+*/
+unsigned int zCgosCgeb(CGOS_DRV_VARS *cdv)
+  {
+  if (cdv->lout<cdv->lin) return CGOS_ERROR;
+  cdv->retcnt=cdv->lout;
+  OsaMemCpy((char *)(cdv->cout+1),(char *)(cdv->cin+1),cdv->lin);
+  CgebInvokeVoid(&cdv->brd->cgeb,(CGEBFPS *)(cdv->cout+1),cdv->lout);
+  return CGOS_SUCCESS;
+  }
+
+unsigned int zCgosCgebTransAddr(CGOS_DRV_VARS *cdv)
+  {
+  cdv->cout->rets[0]=CgebTransAddr(&cdv->brd->cgeb,cdv->cin->pars[0]);
+  return CGOS_SUCCESS;
+  }
+
+/*
+unsigned int zCgosVgaCount(CGOS_DRV_VARS *cdv)
+  {
+  return CGOS_SUCCESS;
+  }
+
+*/
+
+unsigned int dbpflevel=0;
+
+unsigned int zCgosCgebDbgLevel(CGOS_DRV_VARS *cdv)
+  {
+  dbpflevel=cdv->cin->pars[0];
+  return CGOS_SUCCESS;
+  }
+
+//***************************************************************************
+
+#define CGOS_DRV_FCT_MAX (sizeof(DrvFcts)/sizeof(*DrvFcts))
+
+#define CDFF_x    0x0000
+#define CDFF_     0x0000
+#define CDFF_NOH  0x0001
+#define CDFF_TYP  0x0002
+#define CDFF_BRD  0x0000
+#define CDFF_VGA  0x0200
+#define CDFF_STO  0x0400
+#define CDFF_I2C  0x0800
+#define CDFF_IO   0x1000
+#define CDFF_WD   0x2000
+
+#define CDFF_MASK 0xFF00
+
+typedef struct {
+  unsigned int xfct;
+  unsigned int  (*fct)(CGOS_DRV_VARS *cdv);
+  unsigned int minin;
+  unsigned int minout;
+  unsigned int flags;
+  unsigned int cgebfct;
+  unsigned int cgebflags;
+  } CGOS_DRV_FCT;
+
+//***************************************************************************
+
+#define xCgebWDogGetConfigStruct xCgebWDogGetConfig
+#define xCgebWDogSetConfigStruct xCgebWDogSetConfig
+
+// driver function call dispatch
+#define X(name) zCgos##name
+#define o(name) NULL
+#define B(name) NULL
+#define Z(name) zCgosSuccess
+
+// cgeb function number dispatch
+#define X2(name) 0
+#define o2(name) 0
+#define B2(name) xCgeb##name
+#define Z2(name) 0
+
+// the first parameter describes how the call will be dispatched:
+//   o: just return not implemented
+//   Z: just return success and zero results
+//   X: dispatch to the drivers zCgos* function with the base name
+//   B: dispatch to the xCgeb* function with the base name
+// the second parameter is the base name
+// the third and fourth parameters are 2 flags for parameter checking
+
+#define df(oX,name,f0,f1,mi,mo,cgebflags) { xCgos##name,oX(name),mi,mo,CDFF_##f0|CDFF_##f1,oX##2(name),cgebflags }
+
+CGOS_DRV_FCT DrvFcts[]={
+  df(X,DrvGetVersion           ,NOH,x  ,0,0,0),
+  df(X,BoardClose              ,BRD,x  ,0,0,0),
+  df(X,BoardCount              ,NOH,x  ,0,0,0),
+  df(X,BoardOpen               ,NOH,x  ,0,0,0),
+  df(X,BoardOpenByNameA        ,NOH,x  ,0,0,0),
+  df(X,BoardGetNameA           ,BRD,x  ,0,CGOS_BOARD_MAX_LEN_ID_STRING,0),
+  df(X,BoardGetInfoA           ,BRD,x  ,0,sizeof(CGOSBOARDINFOA),0),
+  df(B,BoardGetBootCounter     ,BRD,x  ,0,0,0),
+  df(B,BoardGetRunningTimeMeter,BRD,x  ,0,0,0),
+  df(o,BoardGetOption          ,BRD,x  ,0,0,0),
+  df(o,BoardSetOption          ,BRD,x  ,0,0,0),
+  df(o,BoardGetBootErrorLog    ,BRD,x  ,0,0,0),
+  df(B,VgaCount                ,x  ,x  ,0,0,0),
+  df(B,VgaGetContrast          ,VGA,x  ,0,0,0),
+  df(B,VgaSetContrast          ,VGA,x  ,0,0,0),
+  df(B,VgaGetContrastEnable    ,VGA,x  ,0,0,0),
+  df(B,VgaSetContrastEnable    ,VGA,x  ,0,0,0),
+  df(B,VgaGetBacklight         ,VGA,x  ,0,0,0),
+  df(B,VgaSetBacklight         ,VGA,x  ,0,0,0),
+  df(B,VgaGetBacklightEnable   ,VGA,x  ,0,0,0),
+  df(B,VgaSetBacklightEnable   ,VGA,x  ,0,0,0),
+  df(B,VgaEndDarkBoot          ,VGA,x  ,0,0,0),
+  df(B,VgaGetInfo              ,VGA,x  ,0,sizeof(CGOSVGAINFO),0),
+  df(X,StorageAreaCount        ,x  ,x  ,0,0,0), // no STO type checks
+  df(X,StorageAreaType         ,STO,x  ,0,0,0),
+  df(X,StorageAreaSize         ,STO,x  ,0,0,0),
+  df(X,StorageAreaBlockSize    ,STO,x  ,0,0,0),
+  df(B,StorageAreaRead         ,STO,x  ,0,0,32),
+  df(B,StorageAreaWrite        ,STO,x  ,0,0,0),
+  df(B,StorageAreaErase        ,STO,x  ,0,0,0),
+  df(B,StorageAreaEraseStatus  ,STO,x  ,0,0,0),
+  df(X,I2CCount                ,x  ,x  ,0,0,0),
+  df(X,I2CType                 ,I2C,x  ,0,0,0),
+  df(X,I2CIsAvailable          ,I2C,x  ,0,0,0),
+  df(X,I2CRead                 ,I2C,x  ,0,0,32),
+  df(X,I2CWrite                ,I2C,x  ,0,0,0),
+  df(X,I2CReadRegister         ,I2C,x  ,0,0,0),
+  df(X,I2CWriteRegister        ,I2C,x  ,0,0,0),
+  df(X,I2CWriteReadCombined    ,I2C,x  ,0,0,0),
+  df(B,IOCount                 ,x  ,x  ,0,0,0),
+  df(X,IOIsAvailable           ,IO ,x  ,0,0,0),
+  df(B,IORead                  ,IO ,x  ,0,0,0),
+  df(B,IOWrite                 ,IO ,x  ,0,0,0),
+  df(X,IOXorAndXor             ,IO ,x  ,0,0,0),
+  df(B,IOGetDirection          ,IO ,x  ,0,0,0),
+  df(B,IOSetDirection          ,IO ,x  ,0,0,0),
+  df(X,IOGetDirectionCaps      ,IO ,x  ,0,0,0),
+  df(X,IOGetNameA              ,IO ,x  ,0,0,0),
+  df(B,WDogCount               ,x  ,x  ,0,0,0),
+  df(X,WDogIsAvailable         ,WD ,x  ,0,0,0),
+  df(B,WDogTrigger             ,WD ,x  ,0,0,0),
+  df(o,WDogGetTriggerCount     ,WD ,x  ,0,0,0),
+  df(o,WDogSetTriggerCount     ,WD ,x  ,0,0,0),
+  df(B,WDogGetConfigStruct     ,WD ,x  ,0,sizeof(unsigned int)*4,16), // first 4 pars of CGOSWDCONFIG are mandatory
+  df(B,WDogSetConfigStruct     ,WD ,x  ,sizeof(unsigned int)*4,0,0),
+  df(X,WDogSetConfig           ,WD ,x  ,0,0,0),
+  df(X,WDogDisable             ,WD ,x  ,0,0,0),
+  df(B,WDogGetInfo             ,WD ,x  ,0,sizeof(CGOSWDINFO),0),
+  df(o,PerformanceGetCurrent   ,x  ,x  ,0,0,0),
+  df(o,PerformanceSetCurrent   ,x  ,x  ,0,0,0),
+  df(o,PerformanceGetPolicyCaps,x  ,x  ,0,0,0),
+  df(o,PerformanceGetPolicy    ,x  ,x  ,0,0,0),
+  df(o,PerformanceSetPolicy    ,x  ,x  ,0,0,0),
+  df(B,TemperatureCount        ,x  ,x  ,0,0,0),
+  df(B,TemperatureGetInfo      ,x  ,x  ,0,sizeof(CGOSTEMPERATUREINFO),0),
+  df(B,TemperatureGetCurrent   ,x  ,x  ,0,0,0),
+  df(B,TemperatureSetLimits    ,x  ,x  ,sizeof(CGOSTEMPERATUREINFO),0,0),
+  df(B,FanCount                ,x  ,x  ,0,0,0),
+  df(B,FanGetInfo              ,x  ,x  ,0,sizeof(CGOSFANINFO),0),
+  df(B,FanGetCurrent           ,x  ,x  ,0,0,0),
+  df(B,FanSetLimits            ,x  ,x  ,sizeof(CGOSFANINFO),0,0),
+  df(B,VoltageCount            ,x  ,x  ,0,0,0),
+  df(B,VoltageGetInfo          ,x  ,x  ,0,sizeof(CGOSVOLTAGEINFO),0),
+  df(B,VoltageGetCurrent       ,x  ,x  ,0,0,0),
+  df(B,VoltageSetLimits        ,x  ,x  ,sizeof(CGOSVOLTAGEINFO),0,0),
+  df(X,Cgeb                    ,x  ,x  ,0,0,0),
+  df(X,CgebTransAddr           ,x  ,x  ,0,0,0),
+  df(X,CgebDbgLevel            ,NOH,x  ,0,0,0),
+  df(B,CgbcGetInfo             ,x  ,x  ,0,sizeof(CGOSBCINFO),0),
+  df(B,CgbcSetControl          ,x  ,x  ,0,0,0),
+  df(B,CgbcReadWrite           ,x  ,x  ,0,0,0),
+  df(B,CgbcHandleCommand       ,x  ,x  ,0,0,128),
+  df(B,StorageAreaLock         ,STO,x  ,0,0,0),
+  df(B,StorageAreaUnlock       ,STO,x  ,0,0,0),
+  df(B,StorageAreaIsLocked     ,STO,x  ,0,0,0),
+  df(X,I2CGetMaxFrequency      ,I2C,x  ,0,0,0),
+  df(B,I2CGetFrequency         ,I2C,x  ,0,0,0),
+  df(B,I2CSetFrequency         ,I2C,x  ,0,0,0),
+  };
+
+#undef X
+#undef o
+#undef B
+#undef X2
+#undef o2
+#undef B2
+#undef df
+
+//***************************************************************************
+
+unsigned int UlaDeviceIoControl(void *hDriver, unsigned int dwIoControlCode,
+    void *pInBuffer, unsigned int nInBufferSize,
+    void *pOutBuffer, unsigned int nOutBufferSize,
+    unsigned int *pBytesReturned)
+  {
+  CGOS_DRV_VARS *cdv=hDriver;
+  CGOSIOCTLIN *cin;
+  CGOSIOCTLOUT *cout;
+  CGOS_DRV_FCT *df;
+  unsigned int dff;
+  if (pBytesReturned) *pBytesReturned=0;
+
+  // check basic ioctl pars
+  if (!cdv || cdv==CGOS_INVALID_HANDLE) return CGOS_INVALID_PARAMETER;
+  if (dwIoControlCode!=CGOS_IOCTL) return CGOS_NOT_IMPLEMENTED;
+  if (nInBufferSize<sizeof(CGOSIOCTLIN)) return CGOS_INVALID_PARAMETER;
+  if (nOutBufferSize<sizeof(CGOSIOCTLOUT)) return CGOS_INVALID_PARAMETER;
+  if (!pInBuffer) return CGOS_INVALID_PARAMETER;
+  if (!pOutBuffer) return CGOS_INVALID_PARAMETER;
+
+  // set up cgos in and out par structures
+  cdv->cin=cin=(CGOSIOCTLIN *)pInBuffer;
+  cdv->cout=cout=(CGOSIOCTLOUT *)pOutBuffer;
+  cdv->nInBufferSize=nInBufferSize;
+  cdv->nOutBufferSize=nOutBufferSize;
+  cdv->status=0;
+
+  dbpf((TT("CGOS: IOCT: ->  sz %02X, fct %02X, hdl %X, typ %X, p(%X,%X,%X,%X)\n"),
+    nInBufferSize,cin->fct,cin->handle,cin->type,cin->pars[0],cin->pars[1],cin->pars[2],cin->pars[3]));
+
+  // get fct descriptor from fct number in cin
+  if (cin->fct>=CGOS_DRV_FCT_MAX) return CGOS_NOT_IMPLEMENTED;
+  df=DrvFcts+cin->fct;
+
+  // REVIEW: this is just a sanity check
+  if (df->xfct!=cin->fct) return CGOS_NOT_IMPLEMENTED;
+
+  // check additional parameter requirements
+  if (nInBufferSize<sizeof(CGOSIOCTLIN)+df->minin) return CGOS_INVALID_PARAMETER;
+  if (nOutBufferSize<sizeof(CGOSIOCTLOUT)+df->minout) return CGOS_INVALID_PARAMETER;
+  cdv->retcnt=df->minout;
+
+  // pure data buffers
+  cdv->pin=cin+1;
+  cdv->pout=cout+1;
+  cdv->lin=nInBufferSize-sizeof(CGOSIOCTLIN);
+  cdv->lout=nOutBufferSize-sizeof(CGOSIOCTLOUT);
+
+  // enforce driver function flags and convert parameters
+  dff=df->flags;
+  if (!(dff&CDFF_NOH)) { // check handle
+    if (!cin->handle || cin->handle>cdv->boardCount) return CGOS_INVALID_PARAMETER;
+    cdv->brd=cdv->boards+cin->handle-1;
+    }
+  if (dff&CDFF_TYP) { // check type
+    if (cin->type) return CGOS_INVALID_PARAMETER; // type must be 0
+    }
+  cdv->unit=cin->type; // defaults to untranslated type
+  switch (dff&CDFF_MASK) {
+    case CDFF_STO:
+      if (!cdv->brd->stoCount) return CGOS_INVALID_PARAMETER;
+      cdv->unit=StoFindType(cdv->brd,cin->type);
+      if (cdv->unit==(unsigned int)-1) return CGOS_INVALID_PARAMETER;
+      cdv->sto=cdv->brd->sto+cdv->unit;
+      break;
+    case CDFF_I2C:
+      if (!cdv->brd->i2cCount) return CGOS_INVALID_PARAMETER;
+      cdv->unit=I2CFindType(cdv->brd,cin->type);
+      if (cdv->unit==(unsigned int)-1) return CGOS_INVALID_PARAMETER;
+      break;
+#if 0
+    case CDFF_WD:
+      if (cin->type) return CGOS_INVALID_PARAMETER; // only one supported
+      cdv->wdog=cdv->brd->wdog+cin->type;
+      break;
+    case CDFF_VGA:
+      if (cin->type) return CGOS_INVALID_PARAMETER; // only one supported
+      cdv->vga=cdv->brd->vga+cin->type;
+      break;
+    case CDFF_I2C:
+      if (cin->type>cdv->brd->i2cCount) return CGOS_INVALID_PARAMETER;
+      break;
+    case CDFF_IO:
+      if (cin->type>cdv->brd->ioCount) return CGOS_INVALID_PARAMETER;
+      cdv->io=cdv->brd->io+cin->type;
+      break;
+#endif
+    }
+// the input and output buffer might point to the same physical buffer
+// so we must always evaluate all input parameters before writing to the
+// output buffers.
+//  cout->rets[0]=0;
+//  cout->rets[1]=0;
+  if (df->fct) {
+    cout->status=(*df->fct)(cdv);
+    }
+  else if (df->cgebfct) {
+    if (!CgebInvokeIoctl(&cdv->brd->cgeb,df->cgebflags,df->cgebfct,cdv))
+      cout->status=cdv->status?cdv->status:CGOS_ERROR;
+//      return CGOS_ERROR;
+    else
+      cout->status=CGOS_SUCCESS;
+    }
+  else {
+    cout->status=CGOS_NOT_IMPLEMENTED;
+    }
+
+  cdv->retcnt+=sizeof(CGOSIOCTLOUT);
+  dbpf((TT("CGOS:  <- IOCT: sz %02X, cnt %02X, sta %X,        p(%X,%X)\n"),
+    nOutBufferSize,cdv->retcnt,cout->status,cout->rets[0],cout->rets[1]));
+
+  if (pBytesReturned) *pBytesReturned=cdv->retcnt;
+  return CGOS_SUCCESS;
+  }
+
+//***************************************************************************
+
+#if (!defined(_MSC_VER) && !defined(__cdecl))
+#define __cdecl
+#endif
+
+void __cdecl CgebEmu(unsigned short cs, CGEBFPS *fps, unsigned short ds);
+
+void *UlaOpenDriver(unsigned long reserved)
+  {
+  CGOS_DRV_VARS *cdv;
+  //  unsigned int basenibbles,baseaddr;
+  unsigned long basenibbles,baseaddr;
+  cdv=OsaMemAlloc(sizeof(*cdv));
+  if (!cdv) return NULL;
+  OsaMemSet(cdv,0,sizeof(*cdv)); // clears boardCount;
+  cdv->osDrvVars=(void *)reserved;
+  for (basenibbles=0xfedc0; (baseaddr=basenibbles&0xf0000); basenibbles<<=4)
+    if (CgebOpen(cdv,(void *)baseaddr,0x10000))
+      return cdv;
+#ifdef CGEBEMU
+  dbpf((TT("CGOS: >>> WARNING: REAL CGEB NOT FOUND! USING EMULATOR! <<<\n")));
+  CgebOpen(cdv,(unsigned char *)CgebEmu,0);
+#endif
+  return cdv;
+  }
+
+void UlaCloseDriver(void *hDriver)
+  {
+  CGOS_DRV_VARS *cdv=hDriver;
+  if (!cdv) return;
+  while (cdv->boardCount)
+    CgebClose(&cdv->boards[--cdv->boardCount].cgeb);
+  OsaMemFree(cdv);
+  }
+
+unsigned int UlaGetBoardCount(void *hDriver)
+  {
+  CGOS_DRV_VARS *cdv=hDriver;
+  return cdv->boardCount;
+  }
+
+unsigned char *UlaGetBoardName(void *hDriver, unsigned int Index)
+  {
+  CGOS_DRV_VARS *cdv=hDriver;
+  if (Index>=cdv->boardCount) return NULL;
+  return cdv->boards[Index].info.szBoard;
+  }
+
+//***************************************************************************
diff --git a/drivers/cgosdrv/CgosDrv.h b/drivers/cgosdrv/CgosDrv.h
new file mode 100644
index 000000000000..a2467fc359fa
--- /dev/null
+++ b/drivers/cgosdrv/CgosDrv.h
@@ -0,0 +1,47 @@
+/*---------------------------------------------------------------------------
+ *
+ * Copyright (c) 2015, congatec AG. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version 2 of 
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation, 
+ * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * The full text of the license may also be found at:        
+ * http://opensource.org/licenses/GPL-2.0
+ *
+ *---------------------------------------------------------------------------
+ */ 
+
+//***************************************************************************
+
+#ifndef _CGOSDRV_H_
+#define _CGOSDRV_H_
+
+//***************************************************************************
+
+#include "DrvOsHdr.h"  // OS specific header files
+#include "CgosDef.h"   // Standard definitions
+#define NOCGOSAPI
+#include "Cgos.h"      // CGOS Library API definitions and functions
+#include "CgosPriv.h"  // CGOS Library API private definitions and functions
+#include "CgosIoct.h"  // CGOS IO Control Driver Interface
+#include "Cgeb.h"      // CGEB definitions
+#include "CgebSda.h"   // CGEB Secure Data Area
+#include "DrvVars.h"   // Driver Variables
+#include "DrvUla.h"    // Driver Upper Layer
+#include "DrvOsa.h"    // CGOS OS Abstraction Layer
+#include "CgebFct.h"   // CGEB functions
+
+//***************************************************************************
+
+#endif
diff --git a/drivers/cgosdrv/CgosIobd.h b/drivers/cgosdrv/CgosIobd.h
new file mode 100644
index 000000000000..abc342f44f8e
--- /dev/null
+++ b/drivers/cgosdrv/CgosIobd.h
@@ -0,0 +1,38 @@
+/*---------------------------------------------------------------------------
+ *
+ * Copyright (c) 2015, congatec AG. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the BSD 2-clause license which 
+ * accompanies this distribution. 
+ *
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the BSD 2-clause license for more details.
+ *
+ * The full text of the license may be found at:        
+ * http://opensource.org/licenses/BSD-2-Clause   
+ *
+ *---------------------------------------------------------------------------
+ */
+ 
+//***************************************************************************
+
+#ifndef _CGOSIOBD_H_
+#define _CGOSIOBD_H_
+
+//***************************************************************************
+
+typedef struct {
+  void *pInBuffer;
+  unsigned int nInBufferSize;
+  void *pOutBuffer;
+  unsigned int nOutBufferSize;
+  unsigned int *pBytesReturned;
+  } IOCTL_BUF_DESC;
+
+//***************************************************************************
+
+#endif
+
diff --git a/drivers/cgosdrv/CgosIoct.h b/drivers/cgosdrv/CgosIoct.h
new file mode 100644
index 000000000000..b3fe3baf34a9
--- /dev/null
+++ b/drivers/cgosdrv/CgosIoct.h
@@ -0,0 +1,148 @@
+/*---------------------------------------------------------------------------
+ *
+ * Copyright (c) 2015, congatec AG. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the BSD 2-clause license which 
+ * accompanies this distribution. 
+ *
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the BSD 2-clause license for more details.
+ *
+ * The full text of the license may be found at:        
+ * http://opensource.org/licenses/BSD-2-Clause   
+ *
+ *---------------------------------------------------------------------------
+ */
+  
+//***************************************************************************
+
+#ifndef _CGOSIOCT_H_
+#define _CGOSIOCT_H_
+
+//***************************************************************************
+
+#define CGOS_DRIVER_MAJOR 1
+
+//***************************************************************************
+
+typedef struct {
+  unsigned int fct;
+  unsigned int handle;
+  unsigned int type;
+  unsigned int pars[4];
+  } CGOSIOCTLIN;
+
+typedef struct {
+  unsigned int status;
+  unsigned int rets[2];
+  } CGOSIOCTLOUT;
+
+//***************************************************************************
+
+#define xCgosDrvGetVersion          0
+#define xCgosBoardClose             1
+#define xCgosBoardCount             2
+#define xCgosBoardOpen              3
+#define xCgosBoardOpenByNameA       4
+#define xCgosBoardGetNameA          5
+#define xCgosBoardGetInfoA          6
+#define xCgosBoardGetBootCounter    7
+#define xCgosBoardGetRunningTimeMeter 8
+#define xCgosBoardGetOption         9
+#define xCgosBoardSetOption        10
+#define xCgosBoardGetBootErrorLog  11
+#define xCgosVgaCount              12
+#define xCgosVgaGetContrast        13
+#define xCgosVgaSetContrast        14
+#define xCgosVgaGetContrastEnable  15
+#define xCgosVgaSetContrastEnable  16
+#define xCgosVgaGetBacklight       17
+#define xCgosVgaSetBacklight       18
+#define xCgosVgaGetBacklightEnable 19
+#define xCgosVgaSetBacklightEnable 20
+#define xCgosVgaEndDarkBoot        21
+#define xCgosVgaGetInfo            22
+#define xCgosStorageAreaCount      23
+#define xCgosStorageAreaType       24
+#define xCgosStorageAreaSize       25
+#define xCgosStorageAreaBlockSize  26
+#define xCgosStorageAreaRead       27
+#define xCgosStorageAreaWrite      28
+#define xCgosStorageAreaErase      29
+#define xCgosStorageAreaEraseStatus 30
+#define xCgosI2CCount              31
+#define xCgosI2CType               32
+#define xCgosI2CIsAvailable        33
+#define xCgosI2CRead               34
+#define xCgosI2CWrite              35
+#define xCgosI2CReadRegister       36
+#define xCgosI2CWriteRegister      37
+#define xCgosI2CWriteReadCombined  38
+#define xCgosIOCount               39
+#define xCgosIOIsAvailable         40
+#define xCgosIORead                41
+#define xCgosIOWrite               42
+#define xCgosIOXorAndXor           43
+#define xCgosIOGetDirection        44
+#define xCgosIOSetDirection        45
+#define xCgosIOGetDirectionCaps    46
+#define xCgosIOGetNameA            47
+#define xCgosWDogCount             48
+#define xCgosWDogIsAvailable       49
+#define xCgosWDogTrigger           50
+#define xCgosWDogGetTriggerCount   51
+#define xCgosWDogSetTriggerCount   52
+#define xCgosWDogGetConfigStruct   53
+#define xCgosWDogSetConfigStruct   54
+#define xCgosWDogSetConfig         55
+#define xCgosWDogDisable           56
+#define xCgosWDogGetInfo           57
+#define xCgosPerformanceGetCurrent 58
+#define xCgosPerformanceSetCurrent 59
+#define xCgosPerformanceGetPolicyCaps 60
+#define xCgosPerformanceGetPolicy  61
+#define xCgosPerformanceSetPolicy  62
+#define xCgosTemperatureCount      63
+#define xCgosTemperatureGetInfo    64
+#define xCgosTemperatureGetCurrent 65
+#define xCgosTemperatureSetLimits  66
+#define xCgosFanCount              67
+#define xCgosFanGetInfo            68
+#define xCgosFanGetCurrent         69
+#define xCgosFanSetLimits          70
+#define xCgosVoltageCount          71
+#define xCgosVoltageGetInfo        72
+#define xCgosVoltageGetCurrent     73
+#define xCgosVoltageSetLimits      74
+#define xCgosCgeb                  75
+#define xCgosCgebTransAddr         76
+#define xCgosCgebDbgLevel          77
+#define xCgosCgbcGetInfo           78
+#define xCgosCgbcSetControl        79
+#define xCgosCgbcReadWrite         80
+#define xCgosCgbcHandleCommand     81
+#define xCgosStorageAreaLock       82
+#define xCgosStorageAreaUnlock     83
+#define xCgosStorageAreaIsLocked   84
+#define xCgosI2CGetMaxFrequency    85
+#define xCgosI2CGetFrequency       86
+#define xCgosI2CSetFrequency       87
+
+
+//***************************************************************************
+
+#ifndef CGOS_IOCTL
+#ifdef CTL_CODE
+#define CGOS_IOCTL (CTL_CODE(44444l,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS))
+#else
+#define CGOS_IOCTL 44444
+#endif
+#endif
+
+//***************************************************************************
+
+#endif
+
diff --git a/drivers/cgosdrv/CgosPriv.h b/drivers/cgosdrv/CgosPriv.h
new file mode 100644
index 000000000000..8c5f066b9f9d
--- /dev/null
+++ b/drivers/cgosdrv/CgosPriv.h
@@ -0,0 +1,121 @@
+/*---------------------------------------------------------------------------
+ *
+ * Copyright (c) 2015, congatec AG. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the BSD 2-clause license which 
+ * accompanies this distribution. 
+ *
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the BSD 2-clause license for more details.
+ *
+ * The full text of the license may be found at:        
+ * http://opensource.org/licenses/BSD-2-Clause   
+ *
+ *---------------------------------------------------------------------------
+ */
+ 
+//***************************************************************************
+
+#ifndef _CGOSPRIV_H_
+#define _CGOSPRIV_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+//***************************************************************************
+//
+// CgbcGetInfo
+//
+
+typedef struct {
+  unsigned int size;
+  unsigned int type;
+  unsigned int flags;
+  unsigned int flashSize;
+  unsigned int eepromSize;
+  unsigned int ramSize;
+  unsigned int firmwareRevision;
+  } CGOSBCINFO, CGEB_BC_INFO;
+
+// BC (sub) type flags
+
+#define CGEB_BC_TYPE_NONE            0x00000000
+#define CGEB_BC_TYPE_UNKNOWN         0x00010000
+#define CGEB_BC_TYPE_EMU             0x00020000
+#define CGEB_BC_TYPE_ATMEL           0x00030000
+#define CGEB_BC_TYPE_ATMEL_ATMEGA    0x00030001
+#define CGEB_BC_TYPE_ATMEL_ATMEGA48  0x00030002
+#define CGEB_BC_TYPE_ATMEL_ATMEGA88  0x00030003
+#define CGEB_BC_TYPE_ATMEL_ATMEGA168 0x00030004
+#define CGEB_BC_TYPE_PIC             0x00040000
+
+// BC flags
+
+#define CGEB_BC_FLAG_I2C   0x00000001
+#define CGEB_BC_FLAG_WD    0x00000002
+#define CGEB_BC_FLAG_EEP   0x00000004
+
+// CgbcSetControl flags
+
+#define CGEB_BC_CONTROL_SS 0
+#define CGEB_BC_CONTROL_RESET 1
+
+#ifndef NOCGOSAPI
+
+//***************************************************************************
+
+//
+// Board Controller functions
+//
+
+cgosret_bool CgosCgbcGetInfo(HCGOS hCgos, unsigned int dwType, CGOSBCINFO *pInfo);
+cgosret_bool CgosCgbcSetControl(HCGOS hCgos, unsigned int dwLine, unsigned int dwSetting);
+cgosret_bool CgosCgbcReadWrite(HCGOS hCgos, unsigned char bDataByte, unsigned char *pDataByte,
+  unsigned int dwClockDelay, unsigned int dwByteDelay);
+cgosret_bool CgosCgbcHandleCommand(HCGOS hCgos, unsigned char *pBytesWrite, unsigned int dwLenWrite,
+  unsigned char *pBytesRead, unsigned int dwLenRead, unsigned int *pdwStatus);
+
+//***************************************************************************
+
+//
+// Backdoor functions
+//
+
+cgosret_bool CgosCgeb(HCGOS hCgos, unsigned char *pBytes, unsigned int dwLen);
+CGOSDLLAPI unsigned char *CGOSAPI CgosCgebTransAddr(HCGOS hCgos, unsigned char *pBytes);
+cgosret_bool CGOSAPI CgosCgebDbgLevel(HCGOS hCgos, unsigned int dwLevel);
+
+//***************************************************************************
+
+//
+// Reserved functions
+//
+
+cgosret_bool CgosBoardGetOption(HCGOS hCgos, unsigned int dwOption, unsigned int *pdwSetting);
+cgosret_bool CgosBoardSetOption(HCGOS hCgos, unsigned int dwOption, unsigned int dwSetting);
+cgosret_bool CgosBoardGetBootErrorLog(HCGOS hCgos, unsigned int dwType, unsigned int *pdwLogType, unsigned char *pBytes, unsigned int *pdwLen);
+cgosret_bool CgosVgaEndDarkBoot(HCGOS hCgos, unsigned int dwReserved);
+
+//***************************************************************************
+
+//
+// Obsolete functions
+//
+
+cgosret_ulong CgosWDogGetTriggerCount(HCGOS hCgos, unsigned int dwType);
+cgosret_bool CgosWDogSetTriggerCount(HCGOS hCgos, unsigned int dwType, unsigned int cnt);
+
+//***************************************************************************
+
+#endif // NOCGOSAPI
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _CGOSPRIV_H_
+
diff --git a/drivers/cgosdrv/DrvLx.c b/drivers/cgosdrv/DrvLx.c
new file mode 100644
index 000000000000..740ab859cfb6
--- /dev/null
+++ b/drivers/cgosdrv/DrvLx.c
@@ -0,0 +1,189 @@
+/*---------------------------------------------------------------------------
+ *
+ * Copyright (c) 2015, congatec AG. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version 2 of 
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation, 
+ * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * The full text of the license may also be found at:        
+ * http://opensource.org/licenses/GPL-2.0
+ *
+ *---------------------------------------------------------------------------
+ */ 
+
+//***************************************************************************
+
+#include <linux/version.h>
+#include <linux/module.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+#include <linux/autoconf.h>
+#else
+#include <generated/autoconf.h>
+#endif
+
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/export.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+
+#include <linux/uaccess.h>
+#include <linux/miscdevice.h>
+#include "CgosIobd.h"
+
+#define cgos_cdecl __attribute__((regparm(0)))
+#include "DrvUla.h"
+#include "DrvOsHdr.h"
+
+#include <linux/uaccess.h>
+
+//***************************************************************************
+
+#define DEVICE_NAME "cgos"
+
+//***************************************************************************
+
+// OS specific driver variables
+
+typedef struct {
+  void *hDriver;
+  struct semaphore semIoCtl;
+  void *devfs_handle;
+  } OS_DRV_VARS;
+
+OS_DRV_VARS osDrvVars;
+
+static struct file_operations cgos_fops;
+struct miscdevice cgos_device = {
+  .minor = MISC_DYNAMIC_MINOR,
+  .name = DEVICE_NAME,
+  .fops = &cgos_fops
+};
+
+//***************************************************************************
+
+int cgos_open(struct inode *_inode, struct file *f)
+  {
+//  MOD_INC_USE_COUNT;
+  return 0;
+  }
+
+int cgos_release(struct inode *_inode, struct file *f)
+  {
+//  MOD_DEC_USE_COUNT;
+  return 0;
+  }
+
+//***************************************************************************
+
+#define return_ioctl(ret) { if (pbuf!=buf) kfree(pbuf); return ret; }
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35)
+#define ioctl unlocked_ioctl
+long cgos_ioctl(struct file *f, unsigned int command, unsigned long arg)
+#else
+int cgos_ioctl(struct inode *_inode, struct file *f, unsigned int command, unsigned long arg)
+#endif
+  {
+  IOCTL_BUF_DESC iobd;
+  unsigned char buf[512];
+  unsigned char *pbuf=buf;
+  unsigned int ret, rlen=0, maxlen;
+
+  if (copy_from_user(&iobd,(IOCTL_BUF_DESC *)arg,sizeof(iobd)))
+    return -EFAULT;
+
+  maxlen=iobd.nInBufferSize>iobd.nOutBufferSize?iobd.nInBufferSize:iobd.nOutBufferSize;
+  if (maxlen>sizeof(buf))
+    pbuf=kmalloc(maxlen,GFP_KERNEL);
+  if (!pbuf) return -ENOMEM;
+
+  if (iobd.nInBufferSize) {
+    if (!iobd.pInBuffer || copy_from_user(pbuf,iobd.pInBuffer,iobd.nInBufferSize))
+      return_ioctl(-EFAULT);
+    }
+
+  ret=cgos_issue_request(command,pbuf,iobd.nInBufferSize,
+     pbuf,iobd.nOutBufferSize,&rlen);
+  if (ret) return_ioctl(-EFAULT);
+
+  if (rlen) {
+    if (!iobd.pOutBuffer || copy_to_user(iobd.pOutBuffer,pbuf,rlen))
+      return_ioctl(-EFAULT);
+    }
+  if (pbuf!=buf) kfree(pbuf);
+  if (iobd.pBytesReturned)
+    if (copy_to_user(iobd.pBytesReturned,&rlen,sizeof(unsigned int)))
+      return -EFAULT;
+
+  return 0;
+  }
+
+unsigned int cgos_issue_request(unsigned int command, void* ibuf, unsigned int isize,
+    void* obuf, unsigned int osize, unsigned int* olen)
+  {
+  unsigned int ret;
+  down(&osDrvVars.semIoCtl);
+  ret=UlaDeviceIoControl(osDrvVars.hDriver,command,ibuf,isize,
+     obuf,osize,olen);
+  up(&osDrvVars.semIoCtl);
+  return ret;
+  }
+EXPORT_SYMBOL(cgos_issue_request);
+
+//***************************************************************************
+static struct file_operations cgos_fops={
+  owner: THIS_MODULE,
+  ioctl: cgos_ioctl,
+  open: cgos_open,
+  release: cgos_release,
+  };
+//***************************************************************************
+
+static int __init cgos_init(void)
+  {
+
+  int error=0;
+
+  memset(&osDrvVars,0,sizeof(osDrvVars));
+  sema_init(&osDrvVars.semIoCtl,1);
+  error = misc_register(&cgos_device);
+
+  if (!error)
+    osDrvVars.hDriver=UlaOpenDriver(0);
+
+  return error;
+  }
+
+//***************************************************************************
+
+void cgos_exit(void)
+  {
+  UlaCloseDriver(osDrvVars.hDriver);
+  misc_deregister(&cgos_device);
+  }
+
+//***************************************************************************
+
+module_init(cgos_init);
+module_exit(cgos_exit);
+
+//***************************************************************************
+
+MODULE_AUTHOR("congatec AG");
+MODULE_DESCRIPTION("CGOS driver");
+MODULE_LICENSE("GPL");
+
+//***************************************************************************
+
diff --git a/drivers/cgosdrv/DrvOsHdr.h b/drivers/cgosdrv/DrvOsHdr.h
new file mode 100644
index 000000000000..24c3a460d13d
--- /dev/null
+++ b/drivers/cgosdrv/DrvOsHdr.h
@@ -0,0 +1,42 @@
+/*---------------------------------------------------------------------------
+ *
+ * Copyright (c) 2015, congatec AG. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version 2 of 
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation, 
+ * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * The full text of the license may also be found at:        
+ * http://opensource.org/licenses/GPL-2.0
+ *
+ *---------------------------------------------------------------------------
+ */ 
+
+//***************************************************************************
+
+#ifndef _DRVOSHDR_H_
+#define _DRVOSHDR_H_
+
+//***************************************************************************
+#ifdef __amd64__
+#define AMD64
+#endif
+
+#include <stddef.h>
+
+unsigned int cgos_issue_request(unsigned int command, void* ibuf, unsigned int isize,
+    void* obuf, unsigned int osize, unsigned int* olen);
+
+//***************************************************************************
+
+#endif
diff --git a/drivers/cgosdrv/DrvOsa.h b/drivers/cgosdrv/DrvOsa.h
new file mode 100644
index 000000000000..342f741379a6
--- /dev/null
+++ b/drivers/cgosdrv/DrvOsa.h
@@ -0,0 +1,56 @@
+/*---------------------------------------------------------------------------
+ *
+ * Copyright (c) 2015, congatec AG. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version 2 of 
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation, 
+ * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * The full text of the license may also be found at:        
+ * http://opensource.org/licenses/GPL-2.0
+ *
+ *---------------------------------------------------------------------------
+ */ 
+
+//***************************************************************************
+
+#ifndef _DRVOSA_H_
+#define _DRVOSA_H_
+
+//***************************************************************************
+
+#ifndef cgos_cdecl
+#define cgos_cdecl
+#endif
+
+//***************************************************************************
+
+cgos_cdecl void OsaSleepms(void *ctx, unsigned int ms);
+cgos_cdecl void OsaWaitus(void *ctx, unsigned int us);
+
+//***************************************************************************
+
+cgos_cdecl void *OsaMapAddress(unsigned int addr, unsigned int len);
+cgos_cdecl void OsaUnMapAddress(void *base, unsigned int len);
+
+//***************************************************************************
+
+cgos_cdecl void *OsaMemAlloc(unsigned int len);
+cgos_cdecl void OsaMemFree(void *p);
+cgos_cdecl void OsaMemCpy(void *d, void *s, unsigned int len);
+cgos_cdecl void OsaMemSet(void *d, char val, unsigned int len);
+
+//***************************************************************************
+
+#endif
+
diff --git a/drivers/cgosdrv/DrvOsaLx.c b/drivers/cgosdrv/DrvOsaLx.c
new file mode 100644
index 000000000000..8ab37e702ef5
--- /dev/null
+++ b/drivers/cgosdrv/DrvOsaLx.c
@@ -0,0 +1,91 @@
+/*---------------------------------------------------------------------------
+ *
+ * Copyright (c) 2015, congatec AG. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version 2 of 
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation, 
+ * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * The full text of the license may also be found at:        
+ * http://opensource.org/licenses/GPL-2.0
+ *
+ *---------------------------------------------------------------------------
+ */ 
+
+//***************************************************************************
+
+#include <linux/version.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+//#include <linux/delay.h>
+#include <asm/io.h>
+#include <linux/vmalloc.h>
+#include <asm/pgtable.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
+#define cgos_ioremap ioremap
+#else
+#define cgos_ioremap ioremap_cache
+#endif
+
+#ifndef PAGE_KERNEL_EXEC
+#define PAGE_KERNEL_EXEC PAGE_KERNEL
+#endif
+
+#define cgos_cdecl __attribute__((regparm(0)))
+#include "DrvOsa.h"
+
+//***************************************************************************
+
+cgos_cdecl void OsaSleepms(void *ctx, unsigned int ms)
+  {
+  current->state=TASK_INTERRUPTIBLE;
+  schedule_timeout((ms*HZ+999)/1000);
+  }
+
+//***************************************************************************
+
+cgos_cdecl void *OsaMapAddress(unsigned int addr, unsigned int len)
+  {
+    return cgos_ioremap(addr,len);
+  }
+
+cgos_cdecl void OsaUnMapAddress(void *base, unsigned int len)
+  {
+    iounmap(base);
+  }
+
+//***************************************************************************
+
+cgos_cdecl void *OsaMemAlloc(unsigned int len)
+  {
+  return __vmalloc(len, GFP_KERNEL, PAGE_KERNEL_EXEC);
+  }
+
+cgos_cdecl void OsaMemFree(void *p)
+  {
+  vfree(p);
+  }
+
+cgos_cdecl void OsaMemCpy(void *d, void *s, unsigned int len)
+  {
+  memcpy(d,s,len);
+  }
+
+cgos_cdecl void OsaMemSet(void *d, char val, unsigned int len)
+  {
+  memset(d,val,len);
+  }
+
+//***************************************************************************
+
diff --git a/drivers/cgosdrv/DrvUla.h b/drivers/cgosdrv/DrvUla.h
new file mode 100644
index 000000000000..bfa89155aed5
--- /dev/null
+++ b/drivers/cgosdrv/DrvUla.h
@@ -0,0 +1,49 @@
+/*---------------------------------------------------------------------------
+ *
+ * Copyright (c) 2015, congatec AG. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version 2 of 
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation, 
+ * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * The full text of the license may also be found at:        
+ * http://opensource.org/licenses/GPL-2.0
+ *
+ *---------------------------------------------------------------------------
+ */ 
+
+//***************************************************************************
+
+#ifndef _DRVULA_H_
+#define _DRVULA_H_
+
+//***************************************************************************
+
+#ifndef cgos_cdecl
+#define cgos_cdecl
+#endif
+
+//***************************************************************************
+
+cgos_cdecl void *UlaOpenDriver(unsigned long reserved);
+cgos_cdecl void UlaCloseDriver(void *hDriver);
+cgos_cdecl unsigned int UlaGetBoardCount(void *hDriver);
+cgos_cdecl unsigned char *UlaGetBoardName(void *hDriver, unsigned int Index);
+cgos_cdecl unsigned int UlaDeviceIoControl(void *hDriver, unsigned int dwIoControlCode,
+    void *pInBuffer, unsigned int nInBufferSize,
+    void *pOutBuffer, unsigned int nOutBufferSize,
+    unsigned int *pBytesReturned);
+
+//***************************************************************************
+
+#endif
diff --git a/drivers/cgosdrv/DrvVars.h b/drivers/cgosdrv/DrvVars.h
new file mode 100644
index 000000000000..40a69510ea90
--- /dev/null
+++ b/drivers/cgosdrv/DrvVars.h
@@ -0,0 +1,139 @@
+/*---------------------------------------------------------------------------
+ *
+ * Copyright (c) 2015, congatec AG. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version 2 of 
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation, 
+ * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * The full text of the license may also be found at:        
+ * http://opensource.org/licenses/GPL-2.0
+ *
+ *---------------------------------------------------------------------------
+ */ 
+
+//***************************************************************************
+
+#ifndef _DRVVARS_H_
+#define _DRVVARS_H_
+
+//***************************************************************************
+
+#define CGOS_DRV_BOARD_MAX 4
+#define CGOS_DRV_STO_MAX 16
+#define CGOS_DRV_WDOG_MAX 4
+#define CGOS_DRV_VGA_MAX 4
+#define CGOS_DRV_IO_MAX 8
+
+//***************************************************************************
+
+typedef struct {
+  CGEB_STORAGEAREA_INFO info;
+  } CGOS_DRV_STO;
+
+typedef struct {
+  CGOSWDCONFIG config;
+  unsigned int valid;
+  } CGOS_DRV_WDOG;
+
+typedef struct {
+  unsigned int value;
+  unsigned int valueValid;
+  unsigned int enabled;
+  unsigned int enabledValid;
+  } CGOS_DRV_DAC;
+
+typedef struct {
+  CGOS_DRV_DAC backlight;
+  CGOS_DRV_DAC contrast;
+  } CGOS_DRV_VGA;
+
+typedef struct {
+  unsigned int num;
+  unsigned int flags;
+  unsigned int outmask;
+  unsigned int inmask;
+  unsigned int shift;
+  unsigned int value;
+  unsigned int valueValid;
+  } CGOS_DRV_IO;
+
+//***************************************************************************
+
+typedef struct {
+  unsigned char *entry;
+  unsigned char *code;
+  unsigned char *data;
+  unsigned short ds;
+  void *mapMem;
+  unsigned char *hiDescStart;
+  unsigned int hiDescLen;
+  } CGOS_DRV_CGEB;
+
+//***************************************************************************
+
+typedef struct {
+  CGOSBOARDINFOA info;
+  unsigned int validFlags;
+  unsigned int stoCount;
+  CGOS_DRV_STO sto[CGOS_DRV_STO_MAX];
+  unsigned int i2cCount;
+  unsigned int wdogCount;
+//  CGOS_DRV_WDOG wdog[CGOS_DRV_WDOG_MAX];
+//  unsigned int vgaCount;
+//  CGOS_DRV_VGA vga[CGOS_DRV_VGA_MAX];
+//  unsigned int ioCount;
+//  CGOS_DRV_IO io[CGOS_DRV_IO_MAX];
+  CGOS_DRV_CGEB cgeb;
+  } CGOS_DRV_BOARD;
+
+//***************************************************************************/
+
+typedef struct {
+  // back pointer to OS specific vars
+  void *osDrvVars;
+
+  // boards
+  unsigned int boardCount;
+  CGOS_DRV_BOARD boards[CGOS_DRV_BOARD_MAX];
+
+  // parameter passing
+  CGOSIOCTLIN *cin;
+  CGOSIOCTLOUT *cout;
+  unsigned int nInBufferSize;
+  unsigned int nOutBufferSize;
+  unsigned int retcnt;
+  unsigned int status;
+
+  // pure data buffers
+  void *pin;
+  void *pout;
+  unsigned int lin;
+  unsigned int lout;
+  // translated type
+  unsigned int unit;
+
+  // translated pointers
+  CGOS_DRV_BOARD *brd;
+  CGOS_DRV_STO *sto;
+//  CGOS_DRV_WDOG *wdog;
+//  CGOS_DRV_VGA *vga;
+//  CGOS_DRV_IO *io;
+//  unsigned int stotype,stosize;
+
+  } CGOS_DRV_VARS;
+
+
+//***************************************************************************
+
+#endif
diff --git a/drivers/cgosdrv/Kconfig b/drivers/cgosdrv/Kconfig
new file mode 100644
index 000000000000..249e2b5fc982
--- /dev/null
+++ b/drivers/cgosdrv/Kconfig
@@ -0,0 +1,25 @@
+#
+# For a description of the syntax of this configuration file,
+# see Documentation/kbuild/kconfig-language.txt.
+#
+# CGOS configuration.
+#
+
+menu "Congatec CGOS API driver"
+
+config CGOS
+	tristate "Congatec CGOS API driver"
+	help
+	  If you want to use the congatec board features you should include
+
+	  If unsure, say Y.
+
+config CGOS_SBR
+	tristate "cgos-sbr"
+	depends on CGOS
+	help
+	  Expose robot head id.
+
+	  If unsure, say N.
+
+endmenu
diff --git a/drivers/cgosdrv/Makefile b/drivers/cgosdrv/Makefile
new file mode 100644
index 000000000000..6b239ef88ad5
--- /dev/null
+++ b/drivers/cgosdrv/Makefile
@@ -0,0 +1,5 @@
+cgosdrv-objs := DrvLx.o DrvOsaLx.o Cgeb.o CgosDrv.o
+
+obj-$(CONFIG_CGOS) 	+= cgosdrv.o
+obj-$(CONFIG_CGOS_SBR)	+= cgos-sbr.o
+clean-files := *.o
diff --git a/drivers/cgosdrv/cgos-sbr.c b/drivers/cgosdrv/cgos-sbr.c
new file mode 100644
index 000000000000..3f7ddb45fb7b
--- /dev/null
+++ b/drivers/cgosdrv/cgos-sbr.c
@@ -0,0 +1,251 @@
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/sysfs.h>
+#include <linux/crypto.h>
+#include <crypto/hash.h>
+
+#include "DrvOsHdr.h"
+#include "CgosDrv.h"
+#include "CgosIoct.h"
+
+#define DRIVER_AUTHOR	"Julien Massot <jmassot@softbankrobotics.com>"
+#define DRIVER_DESC	"CGOS SBR driver"
+#define DRIVER_NAME	"cgos-sbr"
+
+enum robot_type {
+	ROBOT_TYPE_UNKNOWN = 0,
+	ROBOT_TYPE_PEPPER_1 = 1,
+	ROBOT_TYPE_PEPPER_18 = 2,
+	ROBOT_TYPE_NAO_6 = 3,
+};
+
+#define HEAD_ID_OFFSET 12
+#define HEAD_ID_LEN 20
+#define MACHINE_ID_LEN 32
+
+/* length of the string plus termination '\0' */
+static char head_id[ HEAD_ID_LEN + 1 ];
+static char sbr_machine_id[ MACHINE_ID_LEN + 1 ];
+static enum robot_type robot_type = ROBOT_TYPE_UNKNOWN;
+
+static ssize_t machineid_show(struct kobject *kobj,
+			struct kobj_attribute *attr, char *buf)
+{
+	return snprintf(buf, MACHINE_ID_LEN + 2, "%s\n", sbr_machine_id);
+}
+
+static ssize_t head_id_show(struct kobject *kobj,
+			struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, head_id);
+}
+
+static ssize_t robot_type_show(struct kobject *kobj,
+			struct kobj_attribute *attr, char *buf)
+{
+	switch (robot_type) {
+	case ROBOT_TYPE_PEPPER_1:
+		return sprintf(buf, "pepper1");
+	case ROBOT_TYPE_PEPPER_18:
+		return sprintf(buf, "pepper18");
+	case ROBOT_TYPE_NAO_6:
+		return sprintf(buf, "nao6");
+	case ROBOT_TYPE_UNKNOWN:
+		break;
+	}
+	return sprintf(buf, "unknwon");
+}
+
+static struct kobject *kobj;
+static struct kobj_attribute sc_attrb =
+	__ATTR(head_id, 0444, head_id_show, NULL);
+
+static struct kobj_attribute sc_attrb_machine_id =
+	__ATTR(machine-id, 0444, machineid_show, NULL);
+
+static struct kobj_attribute sc_attrib_robot_type =
+	__ATTR(robot_type, 0444, robot_type_show, NULL);
+
+#define MD5_SIGNATURE_SIZE 16
+
+static int compute_machine_id(void)
+{
+	struct crypto_shash *shash;
+	struct shash_desc *desc;
+	u8 hashval[MD5_SIGNATURE_SIZE];
+	int err, i;
+
+	shash = crypto_alloc_shash("md5", 0, 0);
+	if (shash == NULL)
+		return -ENOMEM;
+
+	desc = kmalloc(sizeof(struct shash_desc) + crypto_shash_descsize(shash), GFP_KERNEL);
+	if (desc == NULL) {
+		err = -ENOMEM;
+		goto error;
+	}
+
+	desc->tfm = shash;
+
+	err = crypto_shash_digest(desc, head_id, HEAD_ID_LEN, hashval);
+	if (err) {
+		printk(KERN_ERR "Fail to compute machine id\n");
+		kfree(desc);
+		goto error;
+	}
+
+	for (i = 0; i < MD5_SIGNATURE_SIZE; i++)
+		sprintf(&sbr_machine_id[2*i], "%02x", hashval[i]);
+
+	kfree(desc);
+  error:
+	crypto_free_shash(shash);
+	return err;
+}
+
+static enum robot_type get_robot_type(const char *head_id)
+{
+	if (strncmp(head_id, "AP990237", 8) == 0)
+		return ROBOT_TYPE_PEPPER_1;
+
+	if (strncmp(head_id, "AP990397", 8) == 0)
+		return ROBOT_TYPE_PEPPER_18;
+
+	if (strncmp(head_id, "P0000074", 8) == 0)
+		return ROBOT_TYPE_NAO_6;
+
+	return ROBOT_TYPE_UNKNOWN;
+}
+
+static int read_head_id(unsigned int handle)
+{
+	CGOSIOCTLIN in_hdr;
+	CGOSIOCTLOUT *out_hdr;
+	unsigned int out_len;
+	unsigned int buflen = sizeof(CGOSIOCTLOUT) + HEAD_ID_LEN + HEAD_ID_OFFSET;
+	unsigned char buffer[buflen];
+	unsigned char *ptr;
+
+	memset(head_id, 0, HEAD_ID_LEN);
+
+	in_hdr.fct = xCgosStorageAreaRead;
+	in_hdr.handle = handle;
+
+	in_hdr.type = CGOS_STORAGE_AREA_EEPROM;
+
+	/* offset */
+	in_hdr.pars[0] = 0;
+	/* length */
+	in_hdr.pars[1] = HEAD_ID_LEN + HEAD_ID_OFFSET;
+	in_hdr.pars[2] = 0;
+	in_hdr.pars[3] = 0;
+
+	cgos_issue_request((unsigned int) CGOS_IOCTL, (unsigned int *) &in_hdr,
+			sizeof(CGOSIOCTLIN), (unsigned int *) buffer,
+			buflen, &out_len);
+
+	out_hdr = (CGOSIOCTLOUT *) buffer;
+	if (out_len != buflen || out_hdr->rets[0] != (HEAD_ID_LEN + HEAD_ID_OFFSET)) {
+		printk(KERN_ERR "Fail to read from eemprom\n");
+		return -EIO;
+	}
+
+	/* skip header to retrieve data */
+	ptr = buffer + sizeof(CGOSIOCTLOUT);
+
+	if (strncmp(ptr, "ALDE00000000", HEAD_ID_OFFSET)) {
+	  printk(KERN_ERR "Fail to read head id from eeprom\n");
+	  return -EIO;
+	}
+
+	memcpy(head_id, ptr + HEAD_ID_OFFSET, HEAD_ID_LEN);
+	head_id[HEAD_ID_LEN] = '\0';
+	return 0;
+}
+
+static int cgos_sbr_board_open(unsigned int *handle)
+{
+	CGOSIOCTLIN in_hdr;
+	CGOSIOCTLOUT out_hdr;
+	unsigned int out_len;
+
+	memset(&in_hdr, 0, sizeof(CGOSIOCTLIN));
+	in_hdr.fct = xCgosBoardOpen;
+
+	cgos_issue_request((unsigned int) CGOS_IOCTL, (unsigned int *) &in_hdr,
+			   sizeof(CGOSIOCTLIN), (unsigned int *) &out_hdr,
+			   sizeof(CGOSIOCTLOUT), &out_len);
+
+	if (out_len < sizeof(CGOSIOCTLOUT)) {
+		return -EIO;
+	}
+
+	*handle = out_hdr.rets[0];
+	return 0;
+}
+
+static void cgos_sbr_board_close(unsigned int handle)
+{
+	CGOSIOCTLIN in_hdr;
+
+	memset(&in_hdr, 0, sizeof(CGOSIOCTLIN));
+	in_hdr.fct     = xCgosBoardClose;
+	in_hdr.handle  = handle;
+
+	cgos_issue_request((unsigned int) CGOS_IOCTL, (unsigned int *) &in_hdr,
+			   sizeof(CGOSIOCTLIN), NULL,
+			   0, NULL);
+}
+
+static int __init cgos_sbr_init(void)
+{
+	unsigned int handle;
+	int err;
+
+	err = cgos_sbr_board_open(&handle);
+	if (err)
+		return err;
+
+	err = read_head_id(handle);
+	if (err)
+		goto error;
+
+	err = compute_machine_id();
+	if (err)
+		goto error;
+
+	robot_type = get_robot_type(head_id);
+
+	kobj = kobject_create_and_add("qi", NULL);
+	if (!kobj) {
+		err = -ENOMEM;
+		goto error;
+	}
+
+	/* Ignore error for sysfs_create_file */
+	err = sysfs_create_file(kobj, &sc_attrb.attr);
+	if (err)
+		goto error;
+	err = sysfs_create_file(kobj, &sc_attrb_machine_id.attr);
+	if (err)
+		goto error;
+	err = sysfs_create_file(kobj, &sc_attrib_robot_type.attr);
+  error:
+	cgos_sbr_board_close(handle);
+	return err;
+}
+
+static void __exit cgos_sbr_exit(void)
+{
+	if (kobj)
+		kobject_put(kobj);
+}
+
+module_init(cgos_sbr_init);
+module_exit(cgos_sbr_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index 2d08a8719506..d7d121e49c0d 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -1278,6 +1278,17 @@ config I2C_TINY_USB
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-tiny-usb.
 
+config SBRE_USB_I2C
+	tristate "SBRE USB-I2C adapter"
+	depends on USB
+	help
+	  If you say yes to this option, support will be included for the
+	  sbre-usb-i2c, a simple USB to I2C interface from SoftBank
+	  Robotics Europe.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called sbre-usb-i2c.
+
 config I2C_VIPERBOARD
 	tristate "Viperboard I2C master support"
 	depends on MFD_VIPERBOARD && USB
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index 3ab8aebc39c9..603f5bdf6484 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -133,6 +133,7 @@ obj-$(CONFIG_I2C_ROBOTFUZZ_OSIF)	+= i2c-robotfuzz-osif.o
 obj-$(CONFIG_I2C_TAOS_EVM)	+= i2c-taos-evm.o
 obj-$(CONFIG_I2C_TINY_USB)	+= i2c-tiny-usb.o
 obj-$(CONFIG_I2C_VIPERBOARD)	+= i2c-viperboard.o
+obj-$(CONFIG_SBRE_USB_I2C)	+= sbre-usb-i2c.o
 
 # Other I2C/SMBus bus drivers
 obj-$(CONFIG_I2C_ACORN)		+= i2c-acorn.o
diff --git a/drivers/i2c/busses/sbre-usb-i2c.c b/drivers/i2c/busses/sbre-usb-i2c.c
new file mode 100644
index 000000000000..8c297d3fc3ee
--- /dev/null
+++ b/drivers/i2c/busses/sbre-usb-i2c.c
@@ -0,0 +1,438 @@
+/*
+ * sbre-usb-i2c.c - I2C driver for SBRE USB to I2C adapter
+ *
+ * Copyright(c)2017 SoftBank Robotics Europe.
+ * Stphane Rgnier <sregnier@softbankrobotics.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/kobject.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysfs.h>
+#include <linux/types.h>
+#include <linux/usb.h>
+#include <linux/completion.h>
+#include <uapi/linux/i2c.h>
+#include <linux/crc32.h>
+
+/* Driver private data */
+struct sbre_usb_i2c {
+	/* devices handles */
+	struct usb_device *usb_dev;
+	struct usb_interface *interface;
+	struct i2c_adapter adapter;
+	/* Bulk buffers, must match firmware max bulk buffer size. */
+	u8 oBuf[1024];
+	u8 iBuf[1024];
+	/* Not used, for future error management */
+	uint64_t lastFailChainStatus;
+};
+
+/* Firmware endpoints */
+#define USB_DATA_EP_IN  0x82
+#define USB_DATA_EP_OUT 0x02
+
+/* Firmware read firmware info, control read parameters. */
+#define USB_READ_FWINFO_REQ     0
+#define USB_READ_FWINFO_REQTYPE 0xA2
+#define USB_READ_FWINFO_LEN     64
+
+/* Communication timeout, 100ms */
+#define USB_IO_TIMEOUT_MS 100
+
+/* Firmware protocol, transaction header */
+struct i2c_cmd_header {
+	/* Address and direction, 7bits address support only.
+	 * Address is left aligned, bit 0 is direction (1 means read).
+	 */
+	uint8_t addrDir;
+	/*
+	 * Exchange flag, meaning depends on direction.
+	 * Host to device: bit 0 is NOSTOP, do not generate STOP and do
+	 *                 a repeated start.
+	 * Device to host: bit 0 is ACK, 1 on success or 0 is nacked.
+	 */
+	uint8_t flags;
+	/* Exchange data len */
+	uint8_t length;
+} __packed;
+/*
+ * Following the header, the exchange data if any, of size
+ * i2c_cmd_header->length.
+ * Condition of data presence: host to device write, or device to host
+ * successful read (i2c_cmd_header->flags & 1).
+ */
+
+/* i2c_cmd_header direction mask */
+#define I2C_DIR_MASK     0x01
+/* i2c_cmd_header direction write */
+#define I2C_DIR_WRITE    0
+/* i2c_cmd_header direction read */
+#define I2C_DIR_READ     1
+
+/* USB management, send bulk command to device */
+static int sbre_usb_i2c_recv(struct i2c_adapter *adapter, void *data, int len);
+/* USB management, receive bulk answer from device */
+static int sbre_usb_i2c_send(struct i2c_adapter *adapter, void *data, int len);
+
+/*
+ * Firmware protocol, bulk an i2c message list into a buffer to send
+ *
+ * Byte 0 is protocol.
+ * Last 4 bytes is a CRC32 validating the whole buffer (Poly 0x04C11DB7).
+ *
+ * Protocol 0 payload:
+ *   - Byte 1 is list length (max 255)
+ *   - List of i2c_cmd_header and data in case of write transaction.
+ */
+static void sbre_usb_i2c_bulk(u8 **buffer, struct i2c_msg *msgs, int nmsgs)
+{
+	int i, j;
+	u8 *buf = *buffer;
+	u32 crc;
+	struct i2c_cmd_header *cmd;
+
+	*buf++ = 0;
+	nmsgs &= 0xff;
+	*buf++ = nmsgs;
+	for (i = 0; i < nmsgs; i++) {
+		cmd = (struct i2c_cmd_header *)buf;
+		cmd->addrDir = (msgs[i].addr&0xff)<<1;
+		cmd->flags = 1; /* nostop */
+		if ((msgs[i].flags & I2C_M_STOP) || i == nmsgs-1)
+			cmd->flags &= ~1;
+		cmd->length = msgs[i].len & 0xff;
+		buf += sizeof(struct i2c_cmd_header);
+		if (msgs[i].flags & I2C_M_RD) {
+			cmd->addrDir |= I2C_DIR_READ;
+		} else {
+			for (j = 0; j < cmd->length; j++)
+				*buf++ = msgs[i].buf[j];
+		}
+	}
+	crc = crc32_le(0xffffffff, *buffer, buf-*buffer) ^ 0xffffffff;
+	*buf++ = crc>>24;
+	*buf++ = (crc>>16)&0xff;
+	*buf++ = (crc>>8)&0xff;
+	*buf++ = crc&0xff;
+	*buffer = buf;
+}
+
+/* Firmware protocol, debulk a buffer and update i2c message list
+ * Returns the number of successful messages (may be 0), else a negative errno.
+ *
+ * Byte 0 is protocol.
+ * Last 4 bytes is a CRC32 validating the whole buffer (Poly 0x04C11DB7).
+ *
+ * Protocol 0 payload:
+ *   - Byte 1 is list length (max 255)
+ *   - List of i2c_cmd_header and data in case of write transaction.
+ *
+ * Every fields from sent list are tested, any difference creates an error.
+ */
+static int sbre_usb_i2c_debulk(struct i2c_msg *msgs, int nmsgs,
+                               u8 *iBuf, int iLen)
+{
+	int i;
+	int successes = 0;
+	u32 crc;
+	u8 *rcrc;
+	struct i2c_cmd_header *cmd = 0;
+
+	if (iLen < 1+4) /* invalid size */
+		return -EIO;
+	crc = crc32_le(0xffffffff, iBuf, iLen-4) ^ 0xffffffff;
+	rcrc = iBuf+iLen-4;
+	if ((crc>>24) != rcrc[0] || ((crc>>16)&0xff) != rcrc[1] ||
+	    ((crc>>8)&0xff) != rcrc[2] || (crc&0xff) != rcrc[3])
+		return -EIO; /* invalid crc */
+	if (iBuf[0] != 0)
+		return -EIO; /* invalid protocol version */
+	if (iLen < 1+1+4) /* invalid size for protocol 0 */
+		return -EIO;
+	if (iBuf[1] != nmsgs)
+		return -EIO; /* numbers of messages mismatch */
+	if (iLen < 1+1+sizeof(struct i2c_cmd_header)*(int)nmsgs+4)
+		return -EIO; /* invalid size */
+	iBuf += 1+1;
+	iLen -= 1+1+4;
+	for (i = 0; i < nmsgs; i++) {
+		if (iLen < sizeof(struct i2c_cmd_header))
+			return -EIO; /* unexpected EOF */
+		cmd = (struct i2c_cmd_header *)iBuf;
+		iBuf += sizeof(struct i2c_cmd_header);
+		iLen -= sizeof(struct i2c_cmd_header);
+		if ((cmd->addrDir>>1) != (msgs[i].addr&0xff))
+			return -EIO; /* invalid address */
+		if (cmd->length != msgs[i].len)
+			return -EIO; /* invalid length */
+		if (msgs[i].flags & I2C_M_RD) {
+			if ((cmd->addrDir & I2C_DIR_MASK) != I2C_DIR_READ)
+				return -EIO; /* invalid direction */
+			if (cmd->flags == 1) {
+				if (iLen < cmd->length)
+					return -EIO; /* unexpected EOF */
+				memcpy(msgs[i].buf, iBuf, cmd->length);
+				iBuf += cmd->length;
+			}
+		}
+		if (cmd->flags == 1)
+			successes++;
+	}
+	return successes;
+}
+
+/*
+ * I2C management, execute transfer requests
+ * Bulk message list, send via bulk endpoint, receive answer on bulk endpoint and debulk messages.
+ */
+static int sbre_usb_i2c_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs, int num)
+{
+	int ret, iLen;
+	struct sbre_usb_i2c *dev = (struct sbre_usb_i2c *)adapter->algo_data;
+	u8 *wbuf = dev->oBuf;
+	u32 wlen = 0;
+
+	dev_dbg(&adapter->dev, "master xfer %d messages:\n", num);
+
+	sbre_usb_i2c_bulk(&wbuf, msgs, num);
+	wlen = wbuf - dev->oBuf;
+	if (sbre_usb_i2c_send(adapter, dev->oBuf, wlen) != wlen) {
+		dev_err(&adapter->dev, "failure writing data\n");
+		ret = -EREMOTEIO;
+		goto out;
+	}
+
+	iLen = sbre_usb_i2c_recv(adapter, dev->iBuf, sizeof(dev->iBuf));
+	if (iLen < 1) {
+		dev_err(&adapter->dev, "failure reading data\n");
+		ret = -EREMOTEIO;
+		goto out;
+	}
+
+	return sbre_usb_i2c_debulk(msgs, num, dev->iBuf, iLen);
+
+out:
+	return ret;
+}
+
+/* I2C management, supported functionnalities */
+static u32 sbre_usb_i2c_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_NOSTART | I2C_FUNC_SMBUS_EMUL;
+}
+
+/* I2C management, algorithm */
+static const struct i2c_algorithm i2c_algo = {
+	.master_xfer	= sbre_usb_i2c_xfer,
+	.functionality	= sbre_usb_i2c_func,
+};
+
+/* USB management, target devices */
+static const struct usb_device_id sbre_usb_i2c_table[] = {
+	{ USB_DEVICE(0xC001, 0x5253) },
+	{ } /* end */
+};
+MODULE_DEVICE_TABLE(usb, sbre_usb_i2c_table);
+
+/* USB management, receive bulk answer from device */
+static int sbre_usb_i2c_recv(struct i2c_adapter *adapter, void *data, int len)
+{
+	struct sbre_usb_i2c *dev = (struct sbre_usb_i2c *)adapter->algo_data;
+	int actual_len = 0;
+	int ret = usb_bulk_msg(dev->usb_dev,
+	                       usb_rcvbulkpipe(dev->usb_dev, USB_DATA_EP_IN),
+	                       data, len, &actual_len,
+	                       USB_IO_TIMEOUT_MS);
+	return ret >= 0 ? actual_len : ret;
+}
+
+/* USB management, send bulk command to device */
+struct bulk_out_context {
+	struct completion done;
+	int status;
+};
+static void sbre_usb_i2c_send_callback(struct urb *urb)
+{
+	struct bulk_out_context *ctx = urb->context;
+	ctx->status = urb->status;
+	complete(&ctx->done);
+}
+static int sbre_usb_i2c_send(struct i2c_adapter *adapter, void *data, int len)
+{
+	struct sbre_usb_i2c *dev = (struct sbre_usb_i2c *)adapter->algo_data;
+	struct bulk_out_context ctx;
+	unsigned long expire;
+	struct urb* urb;
+	int ret;
+
+	urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!urb)
+		return -ENOMEM;
+
+	usb_fill_bulk_urb(urb, dev->usb_dev,
+	                       usb_sndbulkpipe(dev->usb_dev, USB_DATA_EP_OUT),
+		data, len,
+		sbre_usb_i2c_send_callback, NULL);
+	// Firmware detects transaction's end with a packet smaller than
+	// max packet size. Insert a zero length packet if needed.
+	urb->transfer_flags |= URB_ZERO_PACKET;
+
+	init_completion(&ctx.done);
+	urb->context = &ctx;
+	urb->actual_length = 0;
+	ret = usb_submit_urb(urb, GFP_NOIO);
+	if (!ret) {
+		expire = msecs_to_jiffies(USB_IO_TIMEOUT_MS);
+		if (!wait_for_completion_timeout(&ctx.done, expire)) {
+			usb_kill_urb(urb);
+			ret = (ctx.status == -ENOENT ? -ETIMEDOUT : ctx.status);
+		} else {
+			ret = ctx.status;
+		}
+	}
+	usb_free_urb(urb);
+
+	return ret >= 0 ? urb->actual_length : ret;
+}
+
+/* USB management, delete device */
+static void sbre_usb_i2c_free(struct sbre_usb_i2c *dev)
+{
+	usb_put_dev(dev->usb_dev);
+	kfree(dev);
+}
+
+/* Future use, attribute describing which message in list succeed or not */
+static ssize_t failChainStatus_show(struct device *adapter_dev,
+                                    struct device_attribute *attr, char *buf)
+{
+	struct i2c_adapter *adapter = container_of(adapter_dev, struct i2c_adapter, dev);
+	struct sbre_usb_i2c *dev = (struct sbre_usb_i2c *)adapter->algo_data;
+
+	return scnprintf(buf, PAGE_SIZE, "%llu\n", dev->lastFailChainStatus++);
+}
+/* Future use, attribute describing which message in list succeed or not */
+static struct device_attribute failChainStatus_attribute = __ATTR_RO(failChainStatus);
+
+/*
+ * USB management, device probing
+ * Does not probe anything, USB VID/PID criteria is enough.
+ * Retrieve firmware info, setup usb device and i2c adapter.
+ */
+static int sbre_usb_i2c_probe(struct usb_interface *interface,
+                              const struct usb_device_id *id)
+{
+	struct sbre_usb_i2c *dev;
+	int rv = -ENOMEM;
+	u8* infos;
+
+	dev_dbg(&interface->dev, "probing usb device\n");
+
+	/* allocate memory for our device state and initialize it */
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (dev == NULL)
+		goto error;
+
+	dev->usb_dev = usb_get_dev(interface_to_usbdev(interface));
+	dev->interface = interface;
+	dev->lastFailChainStatus = 24;
+
+	/* save our data pointer in this interface device */
+	usb_set_intfdata(interface, dev);
+
+	/* setup i2c adapter description */
+	dev->adapter.owner = THIS_MODULE;
+	dev->adapter.class = I2C_CLASS_HWMON;
+	dev->adapter.algo = &i2c_algo;
+	dev->adapter.algo_data = dev;
+	snprintf(dev->adapter.name, sizeof(dev->adapter.name),
+	         "SBRE USB-I2C on port %d.%d",
+	         dev->usb_dev->bus->busnum,
+	         dev->usb_dev->devnum);
+
+	/* retrieve firmware info */
+	infos = kmalloc(USB_READ_FWINFO_LEN, GFP_KERNEL);
+	if (infos == NULL)
+		goto error;
+	rv = usb_control_msg(dev->usb_dev,
+	                     usb_rcvctrlpipe(dev->usb_dev, 0),
+	                     USB_READ_FWINFO_REQ, USB_READ_FWINFO_REQTYPE,
+	                     0, 0,
+	                     infos, USB_READ_FWINFO_LEN, USB_IO_TIMEOUT_MS);
+	if (rv >= 0) {
+		dev_info(&interface->dev,
+		         "SBRE USB-I2C on port %d.%d: '%s'",
+		         dev->usb_dev->bus->busnum,
+		         dev->usb_dev->devnum,
+		         infos);
+	}
+	kfree(infos);
+
+	dev->adapter.dev.parent = &dev->interface->dev;
+
+	/* attach to i2c layer */
+	i2c_add_adapter(&dev->adapter);
+
+	/* inform user about successful attachment to i2c layer */
+	dev_info(&dev->adapter.dev,
+	         "Connected with SBRE-USB-I2C on port %d.%d\n",
+	         dev->usb_dev->bus->busnum,
+	         dev->usb_dev->devnum);
+
+	rv = sysfs_create_file(&dev->adapter.dev.kobj,
+	                       &failChainStatus_attribute.attr);
+	if (rv)
+		dev_err(&interface->dev, "Can't create sysfs file");
+
+	return rv;
+
+ error:
+	if (dev)
+		sbre_usb_i2c_free(dev);
+
+	return rv;
+}
+
+/* USB management, device disconnection */
+static void sbre_usb_i2c_disconnect(struct usb_interface *interface)
+{
+	struct sbre_usb_i2c *dev = usb_get_intfdata(interface);
+
+	if (dev) {
+		sysfs_remove_file(&dev->adapter.dev.kobj, &failChainStatus_attribute.attr);
+		i2c_del_adapter(&dev->adapter);
+		usb_set_intfdata(interface, NULL);
+		sbre_usb_i2c_free(dev);
+		dev_info(&interface->dev, "disconnected\n");
+	}
+}
+
+/* USB management, driver */
+static struct usb_driver sbre_usb_i2c_driver = {
+	.name       = "sbre-usb-i2c",
+	.probe      = sbre_usb_i2c_probe,
+	.disconnect = sbre_usb_i2c_disconnect,
+	.id_table   = sbre_usb_i2c_table,
+};
+
+module_usb_driver(sbre_usb_i2c_driver);
+
+MODULE_AUTHOR("Stphane Rgnier <sregnier@softbankrobotics.com>");
+MODULE_DESCRIPTION("sbre-usb-i2c driver v2.0");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mmc/host/sdhci-pci-core.c b/drivers/mmc/host/sdhci-pci-core.c
index a9151bd27211..9470794d0b20 100644
--- a/drivers/mmc/host/sdhci-pci-core.c
+++ b/drivers/mmc/host/sdhci-pci-core.c
@@ -1223,7 +1223,8 @@ static const struct sdhci_pci_fixes sdhci_intel_byt_emmc = {
 			  SDHCI_QUIRK_NO_LED,
 	.quirks2	= SDHCI_QUIRK2_PRESET_VALUE_BROKEN |
 			  SDHCI_QUIRK2_CAPS_BIT63_FOR_HS400 |
-			  SDHCI_QUIRK2_STOP_WITH_TC,
+			  SDHCI_QUIRK2_STOP_WITH_TC |
+			  SDHCI_QUIRK2_NO_1_8_V,
 	.ops		= &sdhci_intel_byt_ops,
 	.priv_size	= sizeof(struct intel_host),
 };
diff --git a/drivers/usb/misc/Kconfig b/drivers/usb/misc/Kconfig
index 9bce583aada3..20bb3d1c8dea 100644
--- a/drivers/usb/misc/Kconfig
+++ b/drivers/usb/misc/Kconfig
@@ -265,3 +265,5 @@ config USB_CHAOSKEY
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called chaoskey.
+
+source "drivers/usb/misc/sbre-dfuse/Kconfig"
diff --git a/drivers/usb/misc/Makefile b/drivers/usb/misc/Makefile
index 0d416eb624bb..4f1fa99801f1 100644
--- a/drivers/usb/misc/Makefile
+++ b/drivers/usb/misc/Makefile
@@ -30,3 +30,5 @@ obj-$(CONFIG_USB_CHAOSKEY)		+= chaoskey.o
 
 obj-$(CONFIG_USB_SISUSBVGA)		+= sisusbvga/
 obj-$(CONFIG_USB_LINK_LAYER_TEST)	+= lvstest.o
+
+obj-$(CONFIG_USB_SBRE_DFUSE)		+= sbre-dfuse/
diff --git a/drivers/usb/misc/sbre-dfuse/Kconfig b/drivers/usb/misc/sbre-dfuse/Kconfig
new file mode 100644
index 000000000000..b5c6b5b8973a
--- /dev/null
+++ b/drivers/usb/misc/sbre-dfuse/Kconfig
@@ -0,0 +1,10 @@
+
+config USB_SBRE_DFUSE
+	tristate "STM32 DfuSe flasher"
+	help
+	  This driver is a STM32 Dfuse flasher.
+	  It detects an STM32 device connected on USB DFU mode then
+	  selects the appropriate firmware for it. In case of
+	  mismatch with actual firmware the device is flashed.
+	  The end of the procedure jumps into device application.
+
diff --git a/drivers/usb/misc/sbre-dfuse/Makefile b/drivers/usb/misc/sbre-dfuse/Makefile
new file mode 100644
index 000000000000..5f9c64f52f46
--- /dev/null
+++ b/drivers/usb/misc/sbre-dfuse/Makefile
@@ -0,0 +1,8 @@
+#
+# Makefile for the sbre-dfuse driver
+#
+
+obj-$(CONFIG_USB_SBRE_DFUSE) += sbre-dfuse.o
+
+sbre-dfuse-objs := sbre_dfuse_driver.o sbre_dfuse.o sbre_dfuse_file.o
+
diff --git a/drivers/usb/misc/sbre-dfuse/sbre_dfuse.c b/drivers/usb/misc/sbre-dfuse/sbre_dfuse.c
new file mode 100644
index 000000000000..d77360486d62
--- /dev/null
+++ b/drivers/usb/misc/sbre-dfuse/sbre_dfuse.c
@@ -0,0 +1,703 @@
+/*
+ * sbre_dfuse.c - SBRE DfuSe flasher - dfuse protocol
+ *
+ * Copyright(c)2017 SoftBank Robotics Europe.
+ * Stphane Rgnier <sregnier@softbankrobotics.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+*/
+
+#include "sbre_dfuse.h"
+#include "sbre_dfuse_file.h"
+
+#include <linux/ctype.h>
+#include <linux/slab.h>
+#include <linux/usb/ch9.h>
+
+/* Offset of firmware info in microcontroller flash image */
+#define SBRE_FIRMWARE_INFO_OFFSET 0xc0
+/* Address of firmware info into microcontroller flash. */
+static const uint32_t sbre_firmware_info_address = 0x08000000 | SBRE_FIRMWARE_INFO_OFFSET;
+
+/* Communication timeout, 1s */
+#define USB_IO_TIMEOUT (1*HZ)
+
+/* Current state of the device (Status.bStatus) */
+#define DFU_STATUS_OK            0
+#define DFU_STATUS_ERRTARGET     1
+#define DFU_STATUS_ERRFILE       2
+#define DFU_STATUS_ERRWRITE      3
+#define DFU_STATUS_ERRERASE      4
+#define DFU_STATUS_ERRCHECKERASE 5
+#define DFU_STATUS_ERRPROG       6
+#define DFU_STATUS_ERRVERIFY     7
+#define DFU_STATUS_ERRADDRESS    8
+#define DFU_STATUS_ERRNOTDONE    9
+#define DFU_STATUS_ERRFIRMWARE   10
+#define DFU_STATUS_ERRVENDOR     11
+#define DFU_STATUS_ERRUSBR       12
+#define DFU_STATUS_ERRPOR        13
+#define DFU_STATUS_ERRUNKNOWN    14
+#define DFU_STATUS_ERRSTALLEDPKT 15
+
+/*
+ * State that the device is going to enter
+ * immediately following the getstatus answer (Status.bState)
+ */
+#define DFU_STATE_APPIDLE              0
+#define DFU_STATE_APPDETACH            1
+#define DFU_STATE_DFUIDLE              2
+#define DFU_STATE_DFUDOWNLOADSYNC      3
+#define DFU_STATE_DFUDOWNLOADBUSY      4
+#define DFU_STATE_DFUDOWNLOADIDLE      5
+#define DFU_STATE_DFUMANIFESTSYNC      6
+#define DFU_STATE_DFUMANIFEST          7
+#define DFU_STATE_DFUMANIFESTWAITRESET 8
+#define DFU_STATE_DFUUPLOADIDLE        9
+#define DFU_STATE_DFUERROR             10
+
+/* USB bmRequestType */
+#define REQTYPE_RCV   (USB_DIR_IN|USB_TYPE_CLASS|USB_RECIP_INTERFACE)
+#define REQTYPE_SND   (USB_DIR_OUT|USB_TYPE_CLASS|USB_RECIP_INTERFACE)
+
+/* USB bRequest */
+#define DFU_REQ_DL        1
+#define DFU_REQ_UL        2
+#define DFU_REQ_GETSTATUS 3
+#define DFU_REQ_CLRSTATUS 4
+#define DFU_REQ_ABORT     6
+
+/*
+ * Dfuse special commands
+ *
+ * ST DFU protocol of STM32 bootloader AN3156. Section 4.2 'Get command'.
+ * http://www.st.com/resource/en/application_note/cd00264379.pdf
+ */
+#define DFUSE_CMD_GET            0
+#define DFUSE_CMD_SET_ADDRESS    0x21
+#define DFUSE_CMD_ERASE          0x41
+#define DFUSE_CMD_READ_UNPROTECT 0x92
+
+/*
+ * Dfuse special command GETSTATUS.
+ * Get current device status and parse it to struct sbre_dfuse_status.
+ * Returns 0 on success, else a negative errno.
+ */
+static int dfuse_get_status(struct sbre_dfuse *dev,
+                            struct sbre_dfuse_status *status)
+{
+	int rv;
+	uint8_t *buf = kmalloc(6, GFP_KERNEL);
+
+	if (!buf)
+		return -ENOMEM;
+
+	rv = usb_control_msg(dev->usb_dev,
+	                     usb_rcvctrlpipe(dev->usb_dev, 0),
+	                     DFU_REQ_GETSTATUS, REQTYPE_RCV,
+	                     0, dev->itf_alt,
+	                     buf, 6, USB_IO_TIMEOUT);
+	if (rv != 6) {
+		kfree(buf);
+		dev_err(&dev->interface->dev, "Cannot get status.");
+		return rv < 0 ? rv : -EREMOTEIO;
+	}
+
+	/* Parse */
+	status->bStatus = buf[0];
+	status->bwPollTimeOut = buf[1] + (buf[2] << 8) + (buf[3] << 16);
+	status->bState = buf[4];
+	status->iString = buf[5];
+	kfree(buf);
+
+	/* Directly sleeps here, assures next command is ok */
+	msleep(status->bwPollTimeOut);
+
+	return 0;
+}
+
+static int dfuse_wait_download_end(struct sbre_dfuse *dev,
+                                   struct sbre_dfuse_status *status)
+{
+	int rv;
+
+	/* Wait while status is downloadbusy */
+	do {
+		rv = dfuse_get_status(dev, status);
+		if (rv < 0)
+			return rv;
+	} while (status->bState == DFU_STATE_DFUDOWNLOADBUSY);
+
+	/* Verify command validated and status ok */
+	if (status->bStatus != DFU_STATUS_OK ||
+	    status->bState != DFU_STATE_DFUDOWNLOADIDLE)
+		return -ECANCELED;
+
+	return 0;
+}
+
+/*
+ * Dfuse command CLRSTATUS.
+ * Asks a jump from state DFU_ERROR to DFU_IDLE
+ *
+ * Returns 0 on success, else a negative errno.
+ */
+static int dfuse_clear_status(struct sbre_dfuse *dev)
+{
+	int rv;
+
+	rv = usb_control_msg(dev->usb_dev,
+	                     usb_sndctrlpipe(dev->usb_dev, 0),
+	                     DFU_REQ_CLRSTATUS, REQTYPE_SND,
+	                     0, dev->itf_alt,
+	                     0, 0, USB_IO_TIMEOUT);
+	if (rv < 0) {
+		dev_err(&dev->interface->dev, "Can't send clear status command.");
+		return -EREMOTEIO;
+	}
+
+	return 0;
+}
+
+/*
+ * Dfuse command BOOT.
+ * Asks a jump from state DFU to firmware
+ *
+ * Returns 0 on success, else a negative errno.
+ */
+static int dfuse_boot(struct sbre_dfuse *dev)
+{
+	int rv;
+	struct sbre_dfuse_status status;
+
+	/* Send boot command (empty download command) */
+	rv = usb_control_msg(dev->usb_dev,
+	                     usb_sndctrlpipe(dev->usb_dev, 0),
+	                     DFU_REQ_DL, REQTYPE_SND,
+	                     0, dev->itf_alt,
+	                     0, 0, USB_IO_TIMEOUT);
+	if (rv < 0) {
+		dev_err(&dev->interface->dev, "Can't send boot command.");
+		return -EREMOTEIO;
+	}
+	/* Activate boot command with a getstatus command */
+	rv = dfuse_get_status(dev, &status);
+	if (rv < 0) {
+		dev_err(&dev->interface->dev,
+		        "Can't boot, state=%u, status=%u.",
+		        status.bState, status.bStatus);
+		return rv;
+	}
+
+	return 0;
+}
+
+/*
+ * Try to bring back Dfuse device to idle state.
+ * Returns 0 on success, else a negative errno.
+ *
+ * See ST user manual UM0424, 10.5.3 DFU state diagram.
+ * http://www.st.com/resource/en/user_manual/cd00158241.pdf
+ */
+static int dfuse_to_idle(struct sbre_dfuse *dev)
+{
+	int rv, tries = 3; /* Max 3 steps to jump from any state to dfuIdle */
+	struct sbre_dfuse_status status;
+
+	do {
+		rv = dfuse_get_status(dev, &status);
+		if (rv < 0)
+			return rv;
+		switch (status.bState) {
+		case DFU_STATE_APPIDLE:
+		case DFU_STATE_APPDETACH:
+			/* No support of DFU mode selection, can't do anything */
+			return 0;
+		case DFU_STATE_DFUERROR:
+			/* DFU error, send a clrstatus command */
+			rv = dfuse_clear_status(dev);
+			if (rv < 0)
+				return rv;
+			break;
+		case DFU_STATE_DFUDOWNLOADSYNC:
+		case DFU_STATE_DFUDOWNLOADIDLE:
+		case DFU_STATE_DFUMANIFESTSYNC:
+		case DFU_STATE_DFUUPLOADIDLE:
+			/* send an abort command */
+			rv = usb_control_msg(dev->usb_dev,
+			                     usb_sndctrlpipe(dev->usb_dev, 0),
+			                     DFU_REQ_ABORT, REQTYPE_SND,
+			                     0, dev->itf_alt,
+			                     0, 0, USB_IO_TIMEOUT);
+			if (rv < 0) {
+				dev_err(&dev->interface->dev, "Can't send abort command.");
+				return -EREMOTEIO;
+			}
+			break;
+		}
+	} while (status.bState != DFU_STATE_DFUIDLE && --tries);
+
+	if (status.bState != DFU_STATE_DFUIDLE) {
+		dev_err(&dev->interface->dev,
+		        "Can't set status to idle, state=%u, status=%u.",
+		        status.bState, status.bStatus);
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+/*
+ * Dfuse special command SETADDRESS. Set current device data pointer.
+ * Returns 0 on success, else a negative errno.
+ */
+static int dfuse_set_address(struct sbre_dfuse *dev, uint32_t addr)
+{
+	int rv;
+	struct sbre_dfuse_status status;
+	uint8_t *buf = kmalloc(5, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+	buf[0] = DFUSE_CMD_SET_ADDRESS;
+	buf[1] = addr&0xff;
+	buf[2] = (addr>>8)&0xff;
+	buf[3] = (addr>>16)&0xff;
+	buf[4] = (addr>>24)&0xff;
+
+	rv = usb_control_msg(dev->usb_dev,
+	                     usb_sndctrlpipe(dev->usb_dev, 0),
+	                     DFU_REQ_DL, REQTYPE_SND,
+	                     0, dev->itf_alt,
+	                     buf, 5, USB_IO_TIMEOUT);
+	kfree(buf);
+
+	if (rv != 5)
+		return rv < 0 ? rv : -EREMOTEIO;
+
+	/* Wait end of download */
+	rv = dfuse_wait_download_end(dev, &status);
+	if (rv < 0) {
+		dev_err(&dev->interface->dev,
+		        "Can't set address 0x%08x, state=%u, status=%u.",
+		        addr, status.bState, status.bStatus);
+		return rv;
+	}
+
+	/* Clean status */
+	rv = dfuse_to_idle(dev);
+	if (rv < 0)
+		return rv;
+
+	return 0;
+}
+
+/*
+ * Dfuse special command ERASESECTOR. Erase given sector address.
+ * Returns 0 on success, else a negative errno.
+ */
+static int dfuse_erase_page(struct sbre_dfuse *dev, uint32_t addr)
+{
+	int rv;
+	struct sbre_dfuse_status status;
+	uint8_t *buf = kmalloc(5, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+	buf[0] = DFUSE_CMD_ERASE;
+	buf[1] = addr&0xff;
+	buf[2] = (addr>>8)&0xff;
+	buf[3] = (addr>>16)&0xff;
+	buf[4] = (addr>>24)&0xff;
+
+	rv = usb_control_msg(dev->usb_dev,
+	                     usb_sndctrlpipe(dev->usb_dev, 0),
+	                     DFU_REQ_DL, REQTYPE_SND,
+	                     0, dev->itf_alt,
+	                     buf, 5, USB_IO_TIMEOUT);
+	kfree(buf);
+
+	if (rv != 5)
+		return rv < 0 ? rv : -EREMOTEIO;
+
+	/* Wait end of download */
+	rv = dfuse_wait_download_end(dev, &status);
+	if (rv < 0) {
+		dev_err(&dev->interface->dev,
+		        "Can't erase page 0x%08x, state=%u, status=%u.",
+		        addr, status.bState, status.bStatus);
+		return rv;
+	}
+
+	return 0;
+}
+
+/*
+ * Download a block to dfuse device.
+ * Returns 0 on success, else a negative errno.
+ */
+static int dfuse_flash_block(struct sbre_dfuse *dev, uint16_t block,
+                             uint8_t *data, uint32_t len)
+{
+	int rv;
+	struct sbre_dfuse_status status;
+
+	rv = usb_control_msg(dev->usb_dev,
+	                     usb_sndctrlpipe(dev->usb_dev, 0),
+	                     DFU_REQ_DL, REQTYPE_SND,
+	                     block, dev->itf_alt,
+	                     data, len, USB_IO_TIMEOUT);
+
+	if (rv != len)
+		return rv < 0 ? rv : -EREMOTEIO;
+
+	/* Wait end of download */
+	rv = dfuse_wait_download_end(dev, &status);
+	if (rv < 0) {
+		dev_err(&dev->interface->dev,
+		        "Can't flash block %u, state=%u, status=%u.",
+		        block, status.bState, status.bStatus);
+		return rv;
+	}
+
+	return 0;
+}
+
+/*
+ * Boot a dfuse device.
+ *
+ * Clear current status, set current address to given one, send boot command
+ * and validate it with a getstatus.
+ *
+ * Returns 0 on success, else a negative errno.
+ */
+int sbre_dfuse_boot(struct sbre_dfuse *dev, uint32_t address)
+{
+	int rv;
+	struct sbre_dfuse_status status;
+
+	/* Verify and clear status */
+	rv = dfuse_to_idle(dev);
+	if (rv < 0)
+		return rv;
+
+	/* Set boot address */
+	rv = dfuse_set_address(dev, address);
+	if (rv < 0)
+		return rv;
+
+	/* Send boot command */
+	rv = dfuse_boot(dev);
+	if (rv < 0)
+		return rv;
+
+	/* Verify status */
+	if (status.bStatus != DFU_STATUS_OK) {
+		dev_err(&dev->interface->dev, "Can't leave, bStatus=%u.",
+		        status.bStatus);
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+/*
+ * Read dfuse device page size from alternate setting string descriptor.
+ * Returns page size on success, else 0
+ *
+ * See ST user manual UM0424, section 10.3.2 "DFU mode descriptor set".
+ * http://www.st.com/resource/en/user_manual/cd00158241.pdf
+ * Example: "@Internal Flash  /0x08000000/064*0002Kg" for STM32F070
+ *
+ * Feedbacks from dfu-util code:
+ * - sector count and size may have more digits than documented
+ * - space may appear between sector size and sector size multiplier
+ * - sector size multiplier may be missing or replaced by a space
+ *
+ * Limitations:
+ * - page size depends on memory sector it writes to. Here only single
+ *   sector type devices is managed.
+ *
+ */
+static uint32_t dfuse_guess_pagesize(struct sbre_dfuse *dev)
+{
+	uint8_t *desc = dev->itf_alt_strdesc;
+	uint32_t pageSize = 0;
+
+	/* Must start with '@' */
+	if (desc[0] != '@')
+		return 0;
+
+	/* Skip name */
+	while (*++desc && *desc != '/');
+	if (!*desc)
+		return 0;
+
+	/* Skip start address */
+	while (*++desc && *desc != '/');
+	if (!*desc)
+		return 0;
+
+	/* Skip first sector count */
+	while (*++desc && *desc != '*');
+	if (!*desc)
+		return 0;
+
+	/* Parse sector size */
+	while (*++desc && '0' <= *desc && *desc <= '9')
+		pageSize = 10*pageSize + *desc - '0';
+	if (!*desc)
+		return 0;
+
+	/* Parse sector multiplier */
+	while (*desc && *desc == ' ')
+		desc++;
+	if (!*desc)
+		return 0;
+	if (*desc == 'K')
+		pageSize *= 1024;
+	else if (*desc == 'M')
+		pageSize *= 1024 * 1024;
+	/* 'B' or nothing means no multiplier */
+
+	return pageSize;
+}
+
+/*
+ * Erase Dfuse element memory. Erase all pages overlapping element data range.
+ * Returns 0 on success, else a negative errno.
+ */
+static int dfuse_erase_element(struct sbre_dfuse *dev, uint32_t elementAddr,
+                               uint32_t elementSize, uint32_t pageSize)
+{
+	int rv;
+	uint32_t pageMask = ~(pageSize-1);
+
+	while (elementSize) {
+		rv = dfuse_erase_page(dev, elementAddr & pageMask);
+		if (rv < 0)
+			return rv;
+		if (elementSize > pageSize) {
+			elementAddr += pageSize;
+			elementSize -= pageSize;
+		} else {
+			elementSize = 0;
+		}
+	}
+
+	/* Cleanup status */
+	rv = dfuse_to_idle(dev);
+	if (rv < 0)
+		return rv;
+
+	return 0;
+}
+
+/*
+ * Flash Dfuse element memory. Flash all element data.
+ * Returns 0 on success, else a negative errno.
+ */
+static int dfuse_flash_element(struct sbre_dfuse *dev, uint32_t elementAddr,
+                               uint32_t elementSize, const uint8_t *elementData)
+{
+	int rv;
+	uint32_t xfer = dev->transferSize;
+	uint16_t block = 2; /* See ST user manual UM0424, 10.5.4 Downloading and uploading. Data is written to AddressSet + (block-2) * transferSize */
+	uint8_t *sendBuf;
+
+	/* Allocate send buffer */
+	sendBuf = kmalloc(dev->transferSize, GFP_KERNEL);
+	if (!sendBuf)
+		return -ENOMEM;
+
+	/* Set start address */
+	rv = dfuse_set_address(dev, elementAddr);
+	if (rv < 0)
+		goto exit;
+
+	/* Write chunks */
+	while (elementSize) {
+		if (elementSize < dev->transferSize)
+			xfer = elementSize;
+		memcpy(sendBuf, elementData, xfer);
+		rv = dfuse_flash_block(dev, block, sendBuf, xfer);
+		if (rv < 0)
+			goto exit;
+		if (elementSize > xfer) {
+			elementData += xfer;
+			elementSize -= xfer;
+			block++;
+		} else {
+			elementSize = 0;
+		}
+	}
+
+	/* Cleanup status */
+	rv = dfuse_to_idle(dev);
+	if (rv < 0)
+		goto exit;
+
+exit:
+	kfree(sendBuf);
+
+	return rv;
+}
+
+/*
+ * Dfuse setup device.
+ *
+ * Select USB interface alternate of flash partition and retrieve
+ * firmware info stored in flash.
+ *
+ * Returns 0 on success, else a negative errno.
+ */
+int sbre_dfuse_setup_device(struct sbre_dfuse *dev)
+{
+	int rv;
+	unsigned i;
+	char *pWr;
+	uint8_t *fwInfo;
+	struct usb_host_interface *altSetting;
+	static const char nonSeparator[] =
+		"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+		"abcdefghijklmnopqrstuvwxyz"
+		"0123456789"
+		"!#$%&()*+,-.:<=>?@[]^_{|}";
+
+	/* Select alternate */
+	for (i = 0; i < dev->interface->num_altsetting; i++) {
+		altSetting = usb_altnum_to_altsetting(dev->interface, i);
+		if (altSetting->string && strstr(altSetting->string, "Internal Flash")) {
+			rv = usb_set_interface(dev->usb_dev,
+			                       altSetting->desc.bInterfaceNumber,
+			                       altSetting->desc.bAlternateSetting);
+			if (rv < 0)
+				return rv;
+			dev->itf_alt = (int)i;
+			snprintf(dev->itf_alt_strdesc, sizeof(dev->itf_alt_strdesc)-1,
+			         altSetting->string);
+			break;
+		}
+	}
+	if (dev->itf_alt < 0) {
+		dev_err(&dev->interface->dev,
+		        "No matching alt setting found, aborting");
+		return -ENOMEDIUM;
+	}
+
+	/* Cleanup status */
+	rv = dfuse_to_idle(dev);
+	if (rv < 0)
+		return rv;
+
+	/* Set address to fwInfo data */
+	rv = dfuse_set_address(dev, sbre_firmware_info_address);
+	if (rv < 0)
+		return rv;
+
+	/* Read fwInfo */
+	fwInfo = kmalloc(sizeof(dev->fwInfo), GFP_KERNEL);
+	if (!fwInfo)
+		return -ENOMEM;
+	rv = usb_control_msg(dev->usb_dev,
+	                     usb_rcvctrlpipe(dev->usb_dev, 0),
+	                     DFU_REQ_UL, REQTYPE_RCV,
+	                     2, dev->itf_alt,
+	                     fwInfo, sizeof(dev->fwInfo), USB_IO_TIMEOUT);
+	if (rv != sizeof(dev->fwInfo))
+	{
+		kfree(fwInfo);
+		return rv < 0 ? rv : -EREMOTEIO;
+	}
+	memcpy(dev->fwInfo, fwInfo, sizeof(dev->fwInfo));
+	kfree(fwInfo);
+
+	/*
+	 * Build firmware path name
+	 * Source is firmware info, cut at first separator, in lower case.
+	 * Separators are chars not in nonSeparator string.
+	 */
+	for (i = 0; i < sizeof(dev->fwInfo); i++)
+		if (!strchr(nonSeparator, dev->fwInfo[i]))
+			break;
+	if (i) {
+		strcpy(dev->fwPath, "sbre-");
+		strncat(dev->fwPath, dev->fwInfo, i);
+		strcat(dev->fwPath, ".dfuse");
+		for (pWr = dev->fwPath; *pWr; pWr++)
+			*pWr = tolower(*pWr);
+	} else {
+		/*
+		 * Name fallback.
+		 * In case of empty firmware info, fallback to first SBRE device
+		 * managed by this driver.
+		 */
+		dev_warn(&dev->interface->dev,
+		         "Can't find firmware info, fallback to usb-i2c firmware.");
+		sprintf(dev->fwPath, "sbre-usb-i2c.dfuse");
+	}
+
+	/* Build printable firmware info */
+	pWr = dev->sInfo;
+	pWr += sprintf(dev->sInfo, "fwInfo: \"");
+	for (i = 0; i < sizeof(dev->fwInfo); i++) {
+		if (isascii(dev->fwInfo[i]))
+			*pWr++ = dev->fwInfo[i];
+		else
+			pWr += sprintf(pWr, "\\x%02x", dev->fwInfo[i]);
+	}
+	pWr += sprintf(pWr, "\" on usb %d.%d.",
+	               dev->usb_dev->bus->busnum, dev->usb_dev->devnum);
+
+	/* Cleanup status */
+	rv = dfuse_to_idle(dev);
+	if (rv < 0)
+		return rv;
+
+	return 0;
+}
+
+/*
+ * Dfuse flash. Erase and flash pages overlapping dfuse file elements.
+ * Returns 0 on success, else a negative errno.
+ *
+ * Simple dfuse flasher, does not test memory mapping, multiple flash sectors or
+ * special memory protections. Only guess page size from first sector found.
+ *
+ * It is assumed that dev->transferSize is correctly set for this device
+ * and memory section.
+ */
+int sbre_dfuse_flash(struct sbre_dfuse *dev, struct sbre_dfuse_file_simple *file)
+{
+	int rv;
+
+	/* TODO verify file alt is selected alt, else change it */
+
+	/* Retrieve page size */
+	uint32_t pageSize = dfuse_guess_pagesize(dev);
+	if (!pageSize) {
+		dev_err(&dev->interface->dev, "Can't guess device page size.");
+		return -EFAULT;
+	}
+
+	/* Erase */
+	rv = dfuse_erase_element(dev, file->elementAddr,
+	                         file->elementSize, pageSize);
+	if (rv < 0)
+		return rv;
+
+	/* Flash */
+	rv = dfuse_flash_element(dev, file->elementAddr,
+	                         file->elementSize, file->element);
+	if (rv < 0)
+		return rv;
+
+	return 0;
+}
+
diff --git a/drivers/usb/misc/sbre-dfuse/sbre_dfuse.h b/drivers/usb/misc/sbre-dfuse/sbre_dfuse.h
new file mode 100644
index 000000000000..327dafe403e9
--- /dev/null
+++ b/drivers/usb/misc/sbre-dfuse/sbre_dfuse.h
@@ -0,0 +1,107 @@
+/*
+ * sbre_dfuse.h - SBRE DfuSe flasher - dfuse protocol
+ *
+ * Copyright(c)2017 SoftBank Robotics Europe.
+ * Stphane Rgnier <sregnier@softbankrobotics.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+*/
+
+#pragma once
+
+#include <linux/types.h>
+#include <linux/kref.h>
+#include <linux/usb.h>
+
+/*
+ * ST DfuSe commands utils
+ * Execute DFU and DFuse commands to update/flash/boot STM32 dfuse devices.
+ *
+ * Limitations:
+ * - No support of DFU mode selection, described into UM0424 section 10.3
+ *   "DFU mode selection". Device must already be in bootloader.
+ * - Device must store firmware info. Used for request_firmware() file path
+ *   and verify if target is up-to-date.
+ *
+ * Documentations:
+ * - Universal Serial Bus Device Class Specification for Device Firmware
+ *   Update v1.1. http://www.usb.org/developers/docs/devclass_docs/DFU_1.1.pdf
+ * - ST DFU protocol of STM32 bootloader AN3156.
+ *   http://www.st.com/resource/en/application_note/cd00264379.pdf
+ * - ST user manual UM0424, section 10.2 "DFU extension protocol".
+ *   http://www.st.com/resource/en/user_manual/cd00158241.pdf
+ */
+
+/* Dfuse status */
+struct sbre_dfuse_status {
+	uint8_t bStatus;        /* Current state of the device */
+	uint32_t bwPollTimeOut; /* ms timeout required before next command */
+	uint8_t bState;         /* State that the device is going to enter
+	                         * immediately following the getstatus answer
+	                         */
+	uint8_t iString;        /* String descriptor number */
+};
+
+/*
+ * Driver private data
+ *
+ * struct usb_device *usb_dev: usb device handle.
+ * struct usb_interface *interface: usb interface handle.
+ * int itf_alt: active USB interface alternate.
+ * uint8_t itf_alt_strdesc[256]: active USB interface alternate string descriptor.
+ * uint8_t fwInfo[]: firmware info (raw, non printable).
+ * char sInfo[]: firmware info (printable, non ascii bytes replaced by "\x%02x").
+ * char fwPath[]: firmware file name.
+ * uint16_t transferSize: payload size of download/upload blocks.
+ *
+ */
+struct sbre_dfuse {
+	struct usb_device *usb_dev;
+	struct usb_interface *interface;
+	struct kref kref;
+	int itf_alt;
+	uint8_t itf_alt_strdesc[256];
+	uint8_t fwInfo[64];              /* Fixed size into firmware */
+	char sInfo[27+4*64];             /* Max size is size of "fwInfo: \"\" on usb XXX.XXX.\0"
+	                                  * plus 64 non printable chars in "\\xXX" notation
+	                                  */
+	char fwPath[12+64];              /* Max size is size of "sbre-.dfuse\0" + fwInfo size */
+	uint16_t transferSize;
+};
+
+#define to_sbre_dfuse_dev(d) container_of(d, struct sbre_dfuse, kref)
+
+/*
+ * Dfuse setup device, SoftBank Robotics Europe-specific.
+ * Select USB interface alternate of flash partition and retrieve fw info
+ * stored in flash.
+ *
+ * Returns 0 on success, else a negative errno.
+ */
+int sbre_dfuse_setup_device(struct sbre_dfuse *dev);
+
+/*
+ * Boot a dfuse device. Clear current status, set current address to given one,
+ * send boot command (empty download command) and validate it with a getstatus.
+ *
+ * Returns 0 on success, else a negative errno.
+ */
+int sbre_dfuse_boot(struct sbre_dfuse *dev, uint32_t address);
+
+/* Dfuse file descriptor */
+struct sbre_dfuse_file_simple;
+
+/*
+ * Dfuse flash. Erase and flash pages overlapping dfuse file elements.
+ *
+ * Returns 0 on success, else a negative errno.
+ */
+int sbre_dfuse_flash(struct sbre_dfuse *dev, struct sbre_dfuse_file_simple *file);
diff --git a/drivers/usb/misc/sbre-dfuse/sbre_dfuse_driver.c b/drivers/usb/misc/sbre-dfuse/sbre_dfuse_driver.c
new file mode 100644
index 000000000000..4b33c7688960
--- /dev/null
+++ b/drivers/usb/misc/sbre-dfuse/sbre_dfuse_driver.c
@@ -0,0 +1,179 @@
+/*
+ * sbre_dfuse_driver.c - SBRE DfuSe flasher - usb driver
+ *
+ * Copyright(c)2017 SoftBank Robotics Europe.
+ * Stphane Rgnier <sregnier@softbankrobotics.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+*/
+
+#include "sbre_dfuse.h"
+#include "sbre_dfuse_file.h"
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/firmware.h>
+
+/* Compatible devices */
+#define USB_VID_STMICROELECTRONICS 0x0483
+#define USB_PID_STM_DEVICE_IN_DFU 0xdf11
+static const struct usb_device_id sbre_dfuse_idtable[] = {
+	{ USB_DEVICE(USB_VID_STMICROELECTRONICS,
+	             USB_PID_STM_DEVICE_IN_DFU) },
+	{ }
+};
+MODULE_DEVICE_TABLE(usb, sbre_dfuse_idtable);
+
+static struct usb_driver sbre_dfuse_driver;
+
+static void sbre_dfuse_delete(struct kref *kref)
+{
+	struct sbre_dfuse *dev = to_sbre_dfuse_dev(kref);
+
+	usb_put_dev(dev->usb_dev);
+	kfree(dev);
+}
+
+static void sbre_dfuse_on_firmware(const struct firmware *fw, void *ctx)
+{
+	struct sbre_dfuse_file_simple file;
+	int rv;
+	struct sbre_dfuse *dev = ctx;
+
+	/* Check firmware loading */
+	if (!fw) {
+		/* We have no idea of boot address, assume 0x08000000 */
+		file.elementAddr = 0x08000000;
+		dev_err(&dev->interface->dev,
+		        "Firmware '%s' not found. Booting anyway at 0x%08x",
+		        dev->fwPath, file.elementAddr);
+		goto boot;
+	}
+
+	/* Parse dfuse file */
+	rv = sbre_dfuse_file_simple_parse(fw->data, fw->size, &file);
+	if (rv < 0) {
+		dev_err(&dev->interface->dev, "Failed to parse dfuse file, err=%d.", rv);
+		goto exit;
+	}
+	dev_dbg(&dev->interface->dev, "Firmware parsed: alt=%u, element @0x%08x size %d, bcdDev=0x%04x, Usb id %04x:%04x.",
+	        file.alt, file.elementAddr, file.elementSize, file.bcdDevice,
+	        file.idVendor, file.idProduct);
+
+	/* Verify fw info */
+	if (!memcmp(file.fwInfo, dev->fwInfo, sizeof(dev->fwInfo))) {
+		/* Same firmware, boot */
+		dev_dbg(&dev->interface->dev, "Firmware up to date, booting.");
+	} else {
+		/* Different, erase, flash then boot */
+		dev_info(&dev->interface->dev, "Firmware mismatch, updating.");
+		rv = sbre_dfuse_flash(dev, &file);
+		if (rv < 0) {
+			dev_err(&dev->interface->dev,
+			        "Failed to flash new firmware, err=%d.", rv);
+			goto exit;
+		}
+		/* Flashed, boot */
+		dev_info(&dev->interface->dev, "Firmware flashed, booting.");
+	}
+
+boot:
+	/* assumes boot address is start of element address */
+	rv = sbre_dfuse_boot(dev, file.elementAddr);
+	if (rv < 0)
+		dev_err(&dev->interface->dev,
+	            "Failed to send boot command, err=%d.", rv);
+
+exit:
+	if (fw)
+		release_firmware(fw);
+}
+
+static int sbre_dfuse_probe(struct usb_interface *interface,
+                           const struct usb_device_id *id)
+{
+	struct sbre_dfuse *dev;
+	int rv = -ENOMEM;
+
+	/* Allocate and init struct sbre_dfuse */
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		goto error;
+
+	kref_init(&dev->kref);
+
+	dev->usb_dev = usb_get_dev(interface_to_usbdev(interface));
+	dev->interface = interface;
+	dev->itf_alt = -1;
+	memset(dev->itf_alt_strdesc, 0, sizeof(dev->itf_alt_strdesc));
+	memset(dev->fwInfo, 0, sizeof(dev->fwInfo));
+	memset(dev->sInfo, 0, sizeof(dev->sInfo));
+	memset(dev->fwPath, 0, sizeof(dev->fwPath));
+	dev->transferSize = 2048; /* from ST app note AN3156, size of flash transfers. */
+
+	/* Save interface private data */
+	usb_set_intfdata(interface, dev);
+
+	/* Dfuse setup (select USB interface alternate of flash partition and retrieve fw info) */
+	rv = sbre_dfuse_setup_device(dev);
+	if (rv < 0) {
+		dev_err(&interface->dev, "Not able to probe dfuse device.");
+		usb_set_intfdata(interface, NULL);
+		goto error;
+	}
+
+	/* Request firmware (dfuse file) */
+	dev_dbg(&interface->dev, "Requesting firmware '%s'.", dev->fwPath);
+	rv = request_firmware_nowait(THIS_MODULE, true, dev->fwPath,
+	                             &dev->usb_dev->dev, GFP_KERNEL, dev,
+	                             sbre_dfuse_on_firmware);
+	if (rv) {
+		dev_err(&interface->dev, "Not able to request firmware.");
+		usb_set_intfdata(interface, NULL);
+		goto error;
+	}
+
+	dev_info(&interface->dev, "STM32 Dfuse device connected. %s", dev->sInfo);
+
+	return 0;
+
+error:
+	if (dev)
+		kref_put(&dev->kref, sbre_dfuse_delete);
+
+	return rv;
+}
+
+static void sbre_dfuse_disconnect(struct usb_interface *interface)
+{
+	struct sbre_dfuse *dev;
+
+	dev = usb_get_intfdata(interface);
+	usb_set_intfdata(interface, NULL);
+
+	dev->interface = NULL;
+
+	kref_put(&dev->kref, sbre_dfuse_delete);
+
+	dev_info(&interface->dev, "STM32 Dfuse device disconnected.");
+}
+
+static struct usb_driver sbre_dfuse_driver = {
+	.name =		"sbre-dfuse",
+	.probe =	sbre_dfuse_probe,
+	.disconnect =	sbre_dfuse_disconnect,
+	.id_table =	sbre_dfuse_idtable,
+};
+module_usb_driver(sbre_dfuse_driver);
+
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/usb/misc/sbre-dfuse/sbre_dfuse_file.c b/drivers/usb/misc/sbre-dfuse/sbre_dfuse_file.c
new file mode 100644
index 000000000000..b4d3a7f75ef6
--- /dev/null
+++ b/drivers/usb/misc/sbre-dfuse/sbre_dfuse_file.c
@@ -0,0 +1,119 @@
+/*
+ * sbre_dfuse_file.c - SBRE DfuSe flasher - dfuse file handling
+ *
+ * Copyright(c)2017 SoftBank Robotics Europe.
+ * Stphane Rgnier <sregnier@softbankrobotics.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+*/
+
+#include "sbre_dfuse_file.h"
+
+#include <linux/string.h>
+#include <linux/crc32.h>
+
+/* Offset of fw info in uC flash image */
+static const uint32_t sbre_usb_i2c_firmware_info_offset = 0xc0;
+
+/* Verify dfuse file CRC */
+static int sbre_dfuse_file_verify_crc(const uint8_t *buf, uint32_t len)
+{
+	uint32_t crc = 0xffffffff;
+	const uint8_t *dwCrc = buf + len - 4;
+
+	crc = ether_crc_le(len - 4, buf);
+	crc ^= dwCrc[0] | (dwCrc[1]<<8) | (dwCrc[2]<<16) | (dwCrc[3]<<24);
+
+	return crc == 0 ? 0 : -1;
+}
+
+/*
+ * Parse dfuse file and fill struct sbre_dfuse_file_simple.
+ * Returns 0 on success, else a negative number.
+ *
+ * Verify dfuse file format header and footer.
+ *
+ * Limitations:
+ * - File is limited to 1 target and 1 element
+ *
+ * Documentation:
+ * - ST User Manual UM0391 - DfuSe File Format Specification
+ */
+int sbre_dfuse_file_simple_parse(const uint8_t *buf, uint32_t len,
+                                struct sbre_dfuse_file_simple *file)
+{
+	const uint8_t *prefix, *targetPrefix, *imageElement, *suffix;
+	uint32_t dfuImageSize, dwTargetSize;
+	const char *szTargetName = 0;
+
+	/* Initialize */
+	memset(file, 0, sizeof(*file));
+
+	/* Verify CRC */
+	if (sbre_dfuse_file_verify_crc(buf, len) < 0)
+		return -1;
+
+	/* Check prefix header (1 target 1 element only) */
+	prefix = buf;
+	if (memcmp(prefix, "DfuSe", 5) || prefix[5] != 1 || prefix[10] != 1)
+		return -2;
+
+	/* Verify total file size is coherent */
+	dfuImageSize = prefix[6] | (prefix[7]<<8) |
+	               (prefix[8]<<16) | (prefix[9]<<24);
+	if (dfuImageSize != len-16)
+		return -3;
+
+	/* Check prefix header */
+	targetPrefix = prefix + 11;
+	if (memcmp(targetPrefix, "Target", 6) || targetPrefix[270] != 1 ||
+	    targetPrefix[271] != 0 || targetPrefix[272] != 0 ||
+	    targetPrefix[273] != 0)
+		return -4;
+
+	/* Check suffix header */
+	suffix = buf + len - 16;
+	if (suffix[6] != 0x1a || suffix[7] != 0x01 ||
+	    memcmp(suffix+8, "UFD", 3) || suffix[11] != 16)
+		return -5;
+
+	/* Verify total file size is coherent */
+	dwTargetSize = targetPrefix[266] | (targetPrefix[267]<<8) |
+	               (targetPrefix[268]<<16) | (targetPrefix[269]<<24);
+	imageElement = targetPrefix + 274;
+	if (imageElement+dwTargetSize != suffix)
+		return -6;
+
+	/* Save target name (if any) */
+	if (targetPrefix[7])
+		szTargetName = &targetPrefix[11];
+
+	/* Target USB interface alternate setting */
+	file->alt = targetPrefix[6];
+
+	/* Save element (firmware) loading address, size and data pointer */
+	file->elementAddr = imageElement[0] | (imageElement[1]<<8) |
+	                    (imageElement[2]<<16) | (imageElement[3]<<24);
+	file->elementSize = imageElement[4] | (imageElement[5]<<8) |
+	                    (imageElement[6]<<16) | (imageElement[7]<<24);
+	file->element = imageElement+8;
+
+	/* Save fw info pointer */
+	file->fwInfo = file->element + sbre_usb_i2c_firmware_info_offset;
+
+	/* Save target bcdDevice and USB VID/PID */
+	file->bcdDevice = suffix[0] | (suffix[1]<<8);
+	file->idProduct = suffix[2] | (suffix[3]<<8);
+	file->idVendor = suffix[4] | (suffix[5]<<8);
+
+	return 0;
+}
+
diff --git a/drivers/usb/misc/sbre-dfuse/sbre_dfuse_file.h b/drivers/usb/misc/sbre-dfuse/sbre_dfuse_file.h
new file mode 100644
index 000000000000..a61b8b58372a
--- /dev/null
+++ b/drivers/usb/misc/sbre-dfuse/sbre_dfuse_file.h
@@ -0,0 +1,53 @@
+/*
+ * sbre_dfuse_file.h - SBRE DfuSe flasher - dfuse file handling
+ *
+ * Copyright(c)2017 SoftBank Robotics Europe.
+ * Stphane Rgnier <sregnier@softbankrobotics.com>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+*/
+
+#pragma once
+
+#include <linux/types.h>
+
+/*
+ * Dfuse file data (simple, just 1 target and 1 element)
+ *
+ * uint8_t alt: target USB interface alternate setting
+ * const uint8_t *fwInfo: pointer to firmware info field (64B wide)
+ * const uint8_t *element: pointer to start of firmware.
+ * uint32_t elementAddr: firmware load address
+ * uint32_t elementSize: firmware size
+ * uint16_t bcdDevice: target bcdDevice (not used)
+ * uint16_t idVendor: target USB VID
+ * uint16_t idProduct: target USB PID
+ *
+ * Documentation:
+ * - ST User Manual UM0391 - DfuSe File Format Specification
+ */
+struct sbre_dfuse_file_simple {
+	uint8_t alt;
+	const uint8_t *fwInfo;
+	const uint8_t *element;
+	uint32_t elementAddr;
+	uint32_t elementSize;
+	uint16_t bcdDevice;
+	uint16_t idVendor;
+	uint16_t idProduct;
+};
+
+/*
+ * Parse dfuse file and fill struct sbre_dfuse_file_simple.
+ * Returns 0 on success, else a negative number.
+ */
+int sbre_dfuse_file_simple_parse(const uint8_t *buf, uint32_t len,
+                                struct sbre_dfuse_file_simple *file);
+
diff --git a/include/cgos/Cgos.h b/include/cgos/Cgos.h
new file mode 100644
index 000000000000..56958fe49b9c
--- /dev/null
+++ b/include/cgos/Cgos.h
@@ -0,0 +1,532 @@
+/*---------------------------------------------------------------------------
+ *
+ * Copyright (c) 2015, congatec AG. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the BSD 2-clause license which 
+ * accompanies this distribution. 
+ *
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the BSD 2-clause license for more details.
+ *
+ * The full text of the license may be found at:        
+ * http://opensource.org/licenses/BSD-2-Clause   
+ *
+ *---------------------------------------------------------------------------
+ */
+ 
+//***************************************************************************
+
+#ifndef _CGOS_H_
+#define _CGOS_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+//***************************************************************************
+
+#ifndef CGOSDLLAPI
+#define CGOSDLLAPI
+#endif
+
+#ifndef CGOSAPI
+#ifndef _WIN32
+#define CGOSAPI
+#elif defined(_MSC_VER) && (_MSC_VER >= 800)
+#define CGOSAPI __stdcall
+#else
+#define CGOSAPI pascal
+#endif
+#endif
+
+#define cgosret_bool CGOSDLLAPI unsigned int CGOSAPI
+#define cgosret_ulong CGOSDLLAPI unsigned int CGOSAPI
+
+//***************************************************************************
+
+#define CgosLibVersionMajor 1
+#define CgosLibVersionMinor 3
+#define CgosLibVersion (((((unsigned int)CgosLibVersionMajor)<<8)+CgosLibVersionMinor)<<16)
+
+//***************************************************************************
+
+typedef struct {
+  unsigned short wYear;
+  unsigned short wMonth;
+  unsigned short wDayOfWeek;
+  unsigned short wDay;
+  unsigned short wHour;
+  unsigned short wMinute;
+  unsigned short wSecond;
+  unsigned short wMilliseconds;
+  } CGOSTIME;
+
+//***************************************************************************
+
+#define CGOS_BOARD_MAX_LEN_ID_STRING 7
+#define CGOS_BOARD_MAX_SIZE_ID_STRING 16
+#define CGOS_BOARD_MAX_LEN_SERIAL_STRING 12
+#define CGOS_BOARD_MAX_SIZE_SERIAL_STRING 16
+#define CGOS_BOARD_MAX_LEN_PART_STRING 16
+#define CGOS_BOARD_MAX_SIZE_PART_STRING 20
+#define CGOS_BOARD_MAX_LEN_EAN_STRING 13
+#define CGOS_BOARD_MAX_SIZE_EAN_STRING 20
+
+typedef struct {
+  unsigned int dwSize;
+  unsigned int dwFlags;
+  char szReserved[CGOS_BOARD_MAX_SIZE_ID_STRING];
+  char szBoard[CGOS_BOARD_MAX_SIZE_ID_STRING];
+  char szBoardSub[CGOS_BOARD_MAX_SIZE_ID_STRING];
+  char szManufacturer[CGOS_BOARD_MAX_SIZE_ID_STRING];
+  CGOSTIME stManufacturingDate;
+  CGOSTIME stLastRepairDate;
+  char szSerialNumber[CGOS_BOARD_MAX_SIZE_SERIAL_STRING];
+  unsigned short wProductRevision;
+  unsigned short wSystemBiosRevision;
+  unsigned short wBiosInterfaceRevision;
+  unsigned short wBiosInterfaceBuildRevision;
+  unsigned int dwClasses;
+  unsigned int dwPrimaryClass;
+  unsigned int dwRepairCounter;
+  char szPartNumber[CGOS_BOARD_MAX_SIZE_PART_STRING];
+  char szEAN[CGOS_BOARD_MAX_SIZE_EAN_STRING];
+  unsigned int dwManufacturer;
+  } CGOSBOARDINFOA;
+
+typedef struct {
+  unsigned int dwSize;
+  unsigned int dwFlags;
+  wchar_t szReserved[CGOS_BOARD_MAX_SIZE_ID_STRING];
+  wchar_t szBoard[CGOS_BOARD_MAX_SIZE_ID_STRING];
+  wchar_t szBoardSub[CGOS_BOARD_MAX_SIZE_ID_STRING];
+  wchar_t szManufacturer[CGOS_BOARD_MAX_SIZE_ID_STRING];
+  CGOSTIME stManufacturingDate;
+  CGOSTIME stLastRepairDate;
+  wchar_t szSerialNumber[CGOS_BOARD_MAX_SIZE_SERIAL_STRING];
+  unsigned short wProductRevision;
+  unsigned short wSystemBiosRevision;
+  unsigned short wBiosInterfaceRevision;
+  unsigned short wBiosInterfaceBuildRevision;
+  unsigned int dwClasses;
+  unsigned int dwPrimaryClass;
+  unsigned int dwRepairCounter;
+  wchar_t szPartNumber[CGOS_BOARD_MAX_SIZE_PART_STRING];
+  wchar_t szEAN[CGOS_BOARD_MAX_SIZE_EAN_STRING];
+  unsigned int dwManufacturer;
+  } CGOSBOARDINFOW;
+
+#ifdef UNICODE
+#define CGOSBOARDINFO CGOSBOARDINFOW
+#define CGOSTCHAR wchar_t
+#else
+#define CGOSBOARDINFO CGOSBOARDINFOA
+#define CGOSTCHAR char
+#endif
+
+//***************************************************************************
+
+//
+// Board handle
+//
+
+typedef unsigned int HCGOS;
+
+//
+// Board Classes
+//
+
+#define CGOS_BOARD_CLASS_CPU 0x00000001
+#define CGOS_BOARD_CLASS_VGA 0x00000002
+#define CGOS_BOARD_CLASS_IO  0x00000004
+
+//
+// Board Open/Count Flags
+//
+
+#define CGOS_BOARD_OPEN_FLAGS_DEFAULT 0
+#define CGOS_BOARD_OPEN_FLAGS_PRIMARYONLY 1
+
+//
+// Max values for LCD settings
+//
+
+#define CGOS_VGA_CONTRAST_MAX 100
+#define CGOS_VGA_BACKLIGHT_MAX 100
+
+// CgosVgaGetInfo
+
+#define CGOS_VGA_TYPE_UNKNOWN  0x00000000
+#define CGOS_VGA_TYPE_CRT      0x00010000
+#define CGOS_VGA_TYPE_LCD      0x00020000
+#define CGOS_VGA_TYPE_LCD_DVO  0x00020001
+#define CGOS_VGA_TYPE_LCD_LVDS 0x00020002
+#define CGOS_VGA_TYPE_TV       0x00030000
+
+typedef struct {
+  unsigned int dwSize;
+  unsigned int dwType;
+  unsigned int dwFlags;
+  unsigned int dwNativeWidth;
+  unsigned int dwNativeHeight;
+  unsigned int dwRequestedWidth;
+  unsigned int dwRequestedHeight;
+  unsigned int dwRequestedBpp;
+  unsigned int dwMaxBacklight;
+  unsigned int dwMaxContrast;
+  } CGOSVGAINFO;
+
+//
+// Type identifiers for storage areas
+//
+
+#define CGOS_STORAGE_AREA_UNKNOWN   0
+#define CGOS_STORAGE_AREA_EEPROM    0x00010000
+#define CGOS_STORAGE_AREA_FLASH     0x00020000
+#define CGOS_STORAGE_AREA_CMOS      0x00030000
+#define CGOS_STORAGE_AREA_RAM       0x00040000
+
+//
+// I2C bus types returned by CgosI2CType()
+//
+
+#define CGOS_I2C_TYPE_UNKNOWN 0           // I2C bus for unknown or special purposes
+#define CGOS_I2C_TYPE_PRIMARY 0x00010000  // primary I2C bus
+#define CGOS_I2C_TYPE_SMB     0x00020000  // system management bus
+#define CGOS_I2C_TYPE_DDC     0x00030000  // I2C bus of the DDC interface
+
+//***************************************************************************
+
+//
+// Watchdog
+//
+
+#define CGOS_WDOG_MODE_REBOOT_PC    0
+#define CGOS_WDOG_MODE_RESTART_OS   1
+#define CGOS_WDOG_MODE_STAGED    0x80
+
+#define CGOS_WDOG_OPMODE_DISABLED      0
+#define CGOS_WDOG_OPMODE_ONETIME_TRIG  1
+#define CGOS_WDOG_OPMODE_SINGLE_EVENT  2
+#define CGOS_WDOG_OPMODE_EVENT_REPEAT  3
+
+#define CGOS_WDOG_EVENT_INT 0 // NMI/IRQ
+#define CGOS_WDOG_EVENT_SCI 1 // SMI/SCI
+#define CGOS_WDOG_EVENT_RST 2 // system reset
+#define CGOS_WDOG_EVENT_BTN 3 // power button
+
+#define CGOS_WDOG_EVENT_MAX_STAGES 3
+
+typedef struct {
+  unsigned int dwTimeout;
+  unsigned int dwEvent;
+  } CGOSWDSTAGE;
+
+typedef struct {
+  unsigned int dwSize;
+  unsigned int dwTimeout; // not used in staged mode
+  unsigned int dwDelay;
+  unsigned int dwMode;
+  // optional parameters for staged watchdog
+  unsigned int dwOpMode;
+  unsigned int dwStageCount;
+  CGOSWDSTAGE stStages[CGOS_WDOG_EVENT_MAX_STAGES];
+  } CGOSWDCONFIG;
+
+// Watch dog info
+
+#define CGOS_WDOG_TYPE_UNKNOWN  0
+#define CGOS_WDOG_TYPE_BC       0x00020000
+#define CGOS_WDOG_TYPE_CHIPSET  0x00030000
+
+typedef struct {
+  unsigned int dwSize;
+  unsigned int dwFlags;
+  unsigned int dwMinTimeout;
+  unsigned int dwMaxTimeout;
+  unsigned int dwMinDelay;
+  unsigned int dwMaxDelay;
+  unsigned int dwOpModes;         // supported operation mode mask (1<<opmode)
+  unsigned int dwMaxStageCount;
+  unsigned int dwEvents;          // supported event mask (1<<event)
+  unsigned int dwType;
+  } CGOSWDINFO;
+
+
+//***************************************************************************
+
+//
+// Temperature, fan, and voltage structures
+//
+
+// Temperature in units of 1/1000th degrees celcius
+
+typedef struct {
+  unsigned int dwSize;
+  unsigned int dwType;
+  unsigned int dwFlags;
+  unsigned int dwAlarm;
+  unsigned int dwRes;
+  unsigned int dwMin;
+  unsigned int dwMax;
+  unsigned int dwAlarmHi;
+  unsigned int dwHystHi;
+  unsigned int dwAlarmLo;
+  unsigned int dwHystLo;
+  } CGOSTEMPERATUREINFO;
+
+// Fan speed values in RPM (revolutions per minute)
+
+typedef struct {
+  unsigned int dwSize;
+  unsigned int dwType;
+  unsigned int dwFlags;
+  unsigned int dwAlarm;
+  unsigned int dwSpeedNom;
+  unsigned int dwMin;
+  unsigned int dwMax;
+  unsigned int dwAlarmHi;
+  unsigned int dwHystHi;
+  unsigned int dwAlarmLo;
+  unsigned int dwHystLo;
+  unsigned int dwOutMin;
+  unsigned int dwOutMax;
+  } CGOSFANINFO;
+
+// Voltage in units of 1/1000th volt
+
+typedef struct {
+  unsigned int dwSize;
+  unsigned int dwType;
+  unsigned int dwNom;
+  unsigned int dwFlags;
+  unsigned int dwAlarm;
+  unsigned int dwRes;
+  unsigned int dwMin;
+  unsigned int dwMax;
+  unsigned int dwAlarmHi;
+  unsigned int dwHystHi;
+  unsigned int dwAlarmLo;
+  unsigned int dwHystLo;
+  } CGOSVOLTAGEINFO;
+
+// Types
+
+#define CGOS_TEMP_CPU           0x00010000
+#define CGOS_TEMP_BOX           0x00020000
+#define CGOS_TEMP_ENV           0x00030000
+#define CGOS_TEMP_BOARD         0x00040000
+#define CGOS_TEMP_BACKPLANE     0x00050000
+#define CGOS_TEMP_CHIPSETS      0x00060000
+#define CGOS_TEMP_VIDEO         0x00070000
+#define CGOS_TEMP_OTHER         0x00080000
+#define CGOS_TEMP_TOPDIMM_ENV   0x00090000      // Top DIMM module environment temperature
+#define CGOS_TEMP_BOTDIMM_ENV   0x000A0000      // Bottom DIMM module environment temperature
+
+#define CGOS_FAN_CPU            0x00010000
+#define CGOS_FAN_BOX            0x00020000
+#define CGOS_FAN_ENV            0x00030000
+#define CGOS_FAN_CHIPSET        0x00040000
+#define CGOS_FAN_VIDEO          0x00050000
+#define CGOS_FAN_OTHER          0x00060000
+
+#define CGOS_VOLTAGE_CPU        0x00010000
+#define CGOS_VOLTAGE_DC         0x00020000
+#define CGOS_VOLTAGE_DC_STANDBY 0x00030000
+#define CGOS_VOLTAGE_BAT_CMOS   0x00040000
+#define CGOS_VOLTAGE_BAT_POWER  0x00050000
+#define CGOS_VOLTAGE_AC         0x00060000
+#define CGOS_VOLTAGE_OTHER      0x00070000
+#define CGOS_VOLTAGE_5V_S0      0x00080000
+#define CGOS_VOLTAGE_5V_S5      0x00090000
+#define CGOS_VOLTAGE_33V_S0     0x000A0000
+#define CGOS_VOLTAGE_33V_S5     0x000B0000
+#define CGOS_VOLTAGE_VCOREA     0x000C0000
+#define CGOS_VOLTAGE_VCOREB     0x000D0000
+#define CGOS_VOLTAGE_12V_S0     0x000E0000
+
+// Due to missing CGOS current sensor definitions 
+// the values of the existing current sensors are 
+// returned in CGOSVOLTAGEINFO as voltage drop of the 
+// respective input current on a 1 Ohm resistor.
+// This allows direct interpretation of this voltage 
+// as input current value in 1/1000th amperes.
+#define CGOS_VCURRENT_DC       	0x80020000
+#define CGOS_VCURRENT_5V_S0     0x80080000
+#define CGOS_VCURRENT_12V_S0    0x800E0000
+
+// Temperature, fan, voltage status flags
+
+#define CGOS_SENSOR_ACTIVE 0x01
+#define CGOS_SENSOR_ALARM 0x02
+#define CGOS_SENSOR_BROKEN 0x04
+#define CGOS_SENSOR_SHORTCIRCUIT 0x08
+
+//***************************************************************************
+
+//
+// Performance
+//
+
+#define CGOS_CPU_PERF_THROTTLING 1
+#define CGOS_CPU_PERF_FREQUENCY 2
+
+//***************************************************************************
+
+#ifndef NOCGOSAPI
+
+// Library
+
+cgosret_ulong CgosLibGetVersion(void);
+cgosret_bool CgosLibInitialize(void);
+cgosret_bool CgosLibUninitialize(void);
+cgosret_bool CgosLibIsAvailable(void);
+cgosret_bool CgosLibInstall(unsigned int install);
+cgosret_ulong CgosLibGetDrvVersion(void);
+cgosret_ulong CgosLibGetLastError(void); // 1.2
+cgosret_bool CgosLibSetLastErrorAddress(unsigned int *pErrNo); // 1.2
+
+// Generic board
+
+cgosret_bool CgosBoardClose(HCGOS hCgos);
+
+cgosret_ulong CgosBoardCount(unsigned int dwClass, unsigned int dwFlags);
+cgosret_bool CgosBoardOpen(unsigned int dwClass, unsigned int dwNum, unsigned int dwFlags, HCGOS *phCgos);
+cgosret_bool CgosBoardOpenByNameA(const char *pszName, HCGOS *phCgos);
+cgosret_bool CgosBoardGetNameA(HCGOS hCgos, char *pszName, unsigned int dwSize);
+cgosret_bool CgosBoardGetInfoA(HCGOS hCgos, CGOSBOARDINFOA *pBoardInfo);
+
+cgosret_bool CgosBoardGetBootCounter(HCGOS hCgos, unsigned int *pdwCount);
+cgosret_bool CgosBoardGetRunningTimeMeter(HCGOS hCgos, unsigned int *pdwCount);
+
+// VGA (LCD)
+
+cgosret_ulong CgosVgaCount(HCGOS hCgos);
+cgosret_bool CgosVgaGetContrast(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwSetting);
+cgosret_bool CgosVgaSetContrast(HCGOS hCgos, unsigned int dwUnit, unsigned int dwSetting);
+cgosret_bool CgosVgaGetContrastEnable(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwSetting);
+cgosret_bool CgosVgaSetContrastEnable(HCGOS hCgos, unsigned int dwUnit, unsigned int dwSetting);
+cgosret_bool CgosVgaGetBacklight(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwSetting);
+cgosret_bool CgosVgaSetBacklight(HCGOS hCgos, unsigned int dwUnit, unsigned int dwSetting);
+cgosret_bool CgosVgaGetBacklightEnable(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwSetting);
+cgosret_bool CgosVgaSetBacklightEnable(HCGOS hCgos, unsigned int dwUnit, unsigned int dwSetting);
+cgosret_bool CgosVgaGetInfo(HCGOS hCgos, unsigned int dwUnit, CGOSVGAINFO *pInfo);
+
+// Storage Areas
+
+cgosret_ulong CgosStorageAreaCount(HCGOS hCgos, unsigned int dwUnit);
+cgosret_ulong CgosStorageAreaType(HCGOS hCgos, unsigned int dwUnit);
+cgosret_ulong CgosStorageAreaSize(HCGOS hCgos, unsigned int dwUnit);
+cgosret_ulong CgosStorageAreaBlockSize(HCGOS hCgos, unsigned int dwUnit);
+cgosret_bool CgosStorageAreaRead(HCGOS hCgos, unsigned int dwUnit, unsigned int dwOffset, unsigned char *pBytes, unsigned int dwLen);
+cgosret_bool CgosStorageAreaWrite(HCGOS hCgos, unsigned int dwUnit, unsigned int dwOffset, unsigned char *pBytes, unsigned int dwLen);
+cgosret_bool CgosStorageAreaErase(HCGOS hCgos, unsigned int dwUnit, unsigned int dwOffset, unsigned int dwLen);
+cgosret_bool CgosStorageAreaEraseStatus(HCGOS hCgos, unsigned int dwUnit, unsigned int dwOffset, unsigned int dwLen, unsigned int *lpStatus);
+cgosret_bool CgosStorageAreaLock(HCGOS hCgos, unsigned int dwUnit, unsigned int dwFlags, unsigned char *pBytes, unsigned int dwLen); // 1.2
+cgosret_bool CgosStorageAreaUnlock(HCGOS hCgos, unsigned int dwUnit, unsigned int dwFlags, unsigned char *pBytes, unsigned int dwLen); // 1.2
+cgosret_bool CgosStorageAreaIsLocked(HCGOS hCgos, unsigned int dwUnit, unsigned int dwFlags); // 1.2
+
+// I2C Bus
+
+cgosret_ulong CgosI2CCount(HCGOS hCgos);
+cgosret_ulong CgosI2CType(HCGOS hCgos, unsigned int dwUnit);
+cgosret_bool CgosI2CIsAvailable(HCGOS hCgos, unsigned int dwUnit);
+cgosret_bool CgosI2CRead(HCGOS hCgos, unsigned int dwUnit, unsigned char bAddr, unsigned char *pBytes, unsigned int dwLen);
+cgosret_bool CgosI2CWrite(HCGOS hCgos, unsigned int dwUnit, unsigned char bAddr, unsigned char *pBytes, unsigned int dwLen);
+
+cgosret_bool CgosI2CReadRegister(HCGOS hCgos, unsigned int dwUnit, unsigned char bAddr, unsigned short wReg, unsigned char *pDataByte);
+cgosret_bool CgosI2CWriteRegister(HCGOS hCgos, unsigned int dwUnit, unsigned char bAddr, unsigned short wReg, unsigned char bData);
+
+cgosret_bool CgosI2CWriteReadCombined(HCGOS hCgos, unsigned int dwUnit, unsigned char bAddr, unsigned char *pBytesWrite,
+  unsigned int dwLenWrite, unsigned char *pBytesRead, unsigned int dwLenRead);
+
+cgosret_bool CgosI2CGetMaxFrequency(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwSetting); // 1.3
+cgosret_bool CgosI2CGetFrequency(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwSetting); // 1.3
+cgosret_bool CgosI2CSetFrequency(HCGOS hCgos, unsigned int dwUnit, unsigned int dwSetting); // 1.3
+
+// General purpose IO
+
+cgosret_ulong CgosIOCount(HCGOS hCgos);
+cgosret_bool CgosIOIsAvailable(HCGOS hCgos, unsigned int dwUnit);
+cgosret_bool CgosIORead(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwData);
+cgosret_bool CgosIOWrite(HCGOS hCgos, unsigned int dwUnit, unsigned int dwData);
+cgosret_bool CgosIOXorAndXor(HCGOS hCgos, unsigned int dwUnit, unsigned int dwXorMask1, unsigned int dwAndMask, unsigned int dwXorMask2);
+cgosret_bool CgosIOGetDirection(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwData);
+cgosret_bool CgosIOSetDirection(HCGOS hCgos, unsigned int dwUnit, unsigned int dwData);
+cgosret_bool CgosIOGetDirectionCaps(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwInputs, unsigned int *pdwOutputs);
+cgosret_bool CgosIOGetNameA(HCGOS hCgos, unsigned int dwUnit, char *pszName, unsigned int dwSize);
+
+// Watchdog
+
+cgosret_ulong CgosWDogCount(HCGOS hCgos);
+cgosret_bool CgosWDogIsAvailable(HCGOS hCgos, unsigned int dwUnit);
+cgosret_bool CgosWDogTrigger(HCGOS hCgos, unsigned int dwUnit);
+cgosret_bool CgosWDogGetConfigStruct(HCGOS hCgos, unsigned int dwUnit, CGOSWDCONFIG *pConfig);
+cgosret_bool CgosWDogSetConfigStruct(HCGOS hCgos, unsigned int dwUnit, CGOSWDCONFIG *pConfig);
+cgosret_bool CgosWDogSetConfig(HCGOS hCgos, unsigned int dwUnit, unsigned int timeout, unsigned int delay, unsigned int mode);
+cgosret_bool CgosWDogDisable(HCGOS hCgos, unsigned int dwUnit);
+cgosret_bool CgosWDogGetInfo(HCGOS hCgos, unsigned int dwUnit, CGOSWDINFO *pInfo);
+
+// CPU Performance
+
+cgosret_bool CgosPerformanceGetCurrent(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwSetting);
+cgosret_bool CgosPerformanceSetCurrent(HCGOS hCgos, unsigned int dwUnit, unsigned int dwSetting);
+cgosret_bool CgosPerformanceGetPolicyCaps(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwSetting);
+cgosret_bool CgosPerformanceGetPolicy(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwSetting);
+cgosret_bool CgosPerformanceSetPolicy(HCGOS hCgos, unsigned int dwUnit, unsigned int dwSetting);
+
+// Temperature
+
+cgosret_ulong CgosTemperatureCount(HCGOS hCgos);
+cgosret_bool CgosTemperatureGetInfo(HCGOS hCgos, unsigned int dwUnit, CGOSTEMPERATUREINFO *pInfo);
+cgosret_bool CgosTemperatureGetCurrent(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwSetting, unsigned int *pdwStatus);
+cgosret_bool CgosTemperatureSetLimits(HCGOS hCgos, unsigned int dwUnit, CGOSTEMPERATUREINFO *pInfo);
+
+// Fan
+
+cgosret_ulong CgosFanCount(HCGOS hCgos);
+cgosret_bool CgosFanGetInfo(HCGOS hCgos, unsigned int dwUnit, CGOSFANINFO *pInfo);
+cgosret_bool CgosFanGetCurrent(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwSetting, unsigned int *pdwStatus);
+cgosret_bool CgosFanSetLimits(HCGOS hCgos, unsigned int dwUnit, CGOSFANINFO *pInfo);
+
+// Voltage
+
+cgosret_ulong CgosVoltageCount(HCGOS hCgos);
+cgosret_bool CgosVoltageGetInfo(HCGOS hCgos, unsigned int dwUnit, CGOSVOLTAGEINFO *pInfo);
+cgosret_bool CgosVoltageGetCurrent(HCGOS hCgos, unsigned int dwUnit, unsigned int *pdwSetting, unsigned int *pdwStatus);
+cgosret_bool CgosVoltageSetLimits(HCGOS hCgos, unsigned int dwUnit, CGOSVOLTAGEINFO *pInfo);
+
+//***************************************************************************
+
+// Unicode
+
+cgosret_bool CgosBoardOpenByNameW(const wchar_t *pszName, HCGOS *phCgos);
+cgosret_bool CgosBoardGetNameW(HCGOS hCgos, wchar_t *pszName, unsigned int dwSize);
+cgosret_bool CgosBoardGetInfoW(HCGOS hCgos, CGOSBOARDINFOW *pBoardInfo);
+cgosret_bool CgosIOGetNameW(HCGOS hCgos, unsigned int dwUnit, wchar_t *pszName, unsigned int dwSize);
+
+#ifdef UNICODE
+#define CgosBoardOpenByName CgosBoardOpenByNameW
+#define CgosBoardGetName CgosBoardGetNameW
+#define CgosBoardGetInfo CgosBoardGetInfoW
+#define CgosIOGetName CgosIOGetNameW
+#else
+#define CgosBoardOpenByName CgosBoardOpenByNameA
+#define CgosBoardGetName CgosBoardGetNameA
+#define CgosBoardGetInfo CgosBoardGetInfoA
+#define CgosIOGetName CgosIOGetNameA
+#endif
+
+#endif
+
+//***************************************************************************
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _CGOS_H_
+
diff --git a/include/cgos/CgosIobd.h b/include/cgos/CgosIobd.h
new file mode 100644
index 000000000000..abc342f44f8e
--- /dev/null
+++ b/include/cgos/CgosIobd.h
@@ -0,0 +1,38 @@
+/*---------------------------------------------------------------------------
+ *
+ * Copyright (c) 2015, congatec AG. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the BSD 2-clause license which 
+ * accompanies this distribution. 
+ *
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the BSD 2-clause license for more details.
+ *
+ * The full text of the license may be found at:        
+ * http://opensource.org/licenses/BSD-2-Clause   
+ *
+ *---------------------------------------------------------------------------
+ */
+ 
+//***************************************************************************
+
+#ifndef _CGOSIOBD_H_
+#define _CGOSIOBD_H_
+
+//***************************************************************************
+
+typedef struct {
+  void *pInBuffer;
+  unsigned int nInBufferSize;
+  void *pOutBuffer;
+  unsigned int nOutBufferSize;
+  unsigned int *pBytesReturned;
+  } IOCTL_BUF_DESC;
+
+//***************************************************************************
+
+#endif
+
diff --git a/sound/pci/hda/Kconfig b/sound/pci/hda/Kconfig
index dae47a45b2b8..303d4c7b845d 100644
--- a/sound/pci/hda/Kconfig
+++ b/sound/pci/hda/Kconfig
@@ -117,6 +117,19 @@ config SND_HDA_CODEC_ANALOG
 comment "Set to Y if you want auto-loading the codec driver"
 	depends on SND_HDA=y && SND_HDA_CODEC_ANALOG=m
 
+config SND_HDA_CODEC_WOLFSON
+	tristate "Build WOLFSON Device HD-audio codec support (Aldebaran)"
+	select SND_HDA_GENERIC
+	help
+	  Say Y or M here to include wolfson Device HD-audio codec support in
+	  snd-hda-intel driver, such as WM8850 or WM8860.
+	  This configuration is designed for Aldebaran software and it is not
+	  compatible with all the device capabilities (2 stereo inputs and 1
+	  stereo output).
+
+comment "Set to Y if you want auto-loading the codec driver"
+	depends on SND_HDA=y && SND_HDA_CODEC_WOLFSON=m
+
 config SND_HDA_CODEC_SIGMATEL
 	tristate "Build IDT/Sigmatel HD-audio codec support"
 	select SND_HDA_GENERIC
diff --git a/sound/pci/hda/Makefile b/sound/pci/hda/Makefile
index b57432f00056..052b9827e646 100644
--- a/sound/pci/hda/Makefile
+++ b/sound/pci/hda/Makefile
@@ -17,6 +17,7 @@ snd-hda-codec-generic-objs :=	hda_generic.o
 snd-hda-codec-realtek-objs :=	patch_realtek.o
 snd-hda-codec-cmedia-objs :=	patch_cmedia.o
 snd-hda-codec-analog-objs :=	patch_analog.o
+snd-hda-codec-wolfson-objs :=	patch_wolfson.o
 snd-hda-codec-idt-objs :=	patch_sigmatel.o
 snd-hda-codec-si3054-objs :=	patch_si3054.o
 snd-hda-codec-cirrus-objs :=	patch_cirrus.o
@@ -34,6 +35,7 @@ obj-$(CONFIG_SND_HDA_GENERIC) += snd-hda-codec-generic.o
 obj-$(CONFIG_SND_HDA_CODEC_REALTEK) += snd-hda-codec-realtek.o
 obj-$(CONFIG_SND_HDA_CODEC_CMEDIA) += snd-hda-codec-cmedia.o
 obj-$(CONFIG_SND_HDA_CODEC_ANALOG) += snd-hda-codec-analog.o
+obj-$(CONFIG_SND_HDA_CODEC_WOLFSON) += snd-hda-codec-wolfson.o
 obj-$(CONFIG_SND_HDA_CODEC_SIGMATEL) += snd-hda-codec-idt.o
 obj-$(CONFIG_SND_HDA_CODEC_SI3054) += snd-hda-codec-si3054.o
 obj-$(CONFIG_SND_HDA_CODEC_CIRRUS) += snd-hda-codec-cirrus.o
diff --git a/sound/pci/hda/hda_generic.c b/sound/pci/hda/hda_generic.c
index 7ac3f04ca8c0..686d4156197a 100644
--- a/sound/pci/hda/hda_generic.c
+++ b/sound/pci/hda/hda_generic.c
@@ -84,7 +84,7 @@ static void free_kctls(struct hda_gen_spec *spec)
 	snd_array_free(&spec->kctls);
 }
 
-static void snd_hda_gen_spec_free(struct hda_gen_spec *spec)
+void snd_hda_gen_spec_free(struct hda_gen_spec *spec)
 {
 	if (!spec)
 		return;
@@ -92,6 +92,7 @@ static void snd_hda_gen_spec_free(struct hda_gen_spec *spec)
 	snd_array_free(&spec->paths);
 	snd_array_free(&spec->loopback_list);
 }
+EXPORT_SYMBOL_GPL(snd_hda_gen_spec_free);
 
 /*
  * store user hints
diff --git a/sound/pci/hda/hda_generic.h b/sound/pci/hda/hda_generic.h
index e728df6145ad..e8adf2fca97d 100644
--- a/sound/pci/hda/hda_generic.h
+++ b/sound/pci/hda/hda_generic.h
@@ -314,6 +314,7 @@ enum {
 };
 
 int snd_hda_gen_spec_init(struct hda_gen_spec *spec);
+void snd_hda_gen_spec_free(struct hda_gen_spec *spec);
 
 int snd_hda_gen_init(struct hda_codec *codec);
 void snd_hda_gen_free(struct hda_codec *codec);
diff --git a/sound/pci/hda/patch_wolfson.c b/sound/pci/hda/patch_wolfson.c
new file mode 100644
index 000000000000..6d4bcbcdefd0
--- /dev/null
+++ b/sound/pci/hda/patch_wolfson.c
@@ -0,0 +1,608 @@
+/*
+ * HD audio interface patch for WM8860
+ *
+ * Copyright (c) 2015 Aldebaran SoftBank Group <edupin@aldebaran.com>
+ *
+ *  This driver is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This driver is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+
+#include <sound/core.h>
+#include <sound/hda_codec.h>
+#include "hda_local.h"
+#include "hda_auto_parser.h"
+#include "hda_beep.h"
+#include "hda_jack.h"
+#include "hda_generic.h"
+
+#define GPIO_MUTE (0x01)
+#define GPIO_MUTE_ENABLE (0x01)
+#define GPIO_MUTE_DISABLE (0x00)
+#define GPIO_AMPLIFICATION (0x02)
+#define GPIO_AMPLIFICATION_ENABLE (0x02)
+#define GPIO_AMPLIFICATION_DISABLE (0x00)
+
+#define SINGLE_PIN_WIDGET_ONLY (0xF0)
+#define CHANNEL_MONO (0x00)
+#define CHANNEL_STEREO (0x01)
+
+#define SET_AMP_STEREO (0x8000 | AC_AMP_SET_LEFT | AC_AMP_SET_RIGHT)
+
+#define VERB_SET_DIFFERENTIAL_MODE (0x7A3)
+#define VERB_GET_DIFFERENTIAL_MODE (0xFA3)
+/* Availlable Value */
+#define DIFFERENTIAL_FULL   (0x00)
+#define DIFFERENTIAL_PSEUDO (0x01)
+
+
+#define NID_PARAMETER (0x01)
+
+#define NID_IO_ADC_1 (0x02)
+#define NID_IO_MIC_1 (0x03)
+#define NID_IO_MIC_2 (0x15)
+#define NID_IO_DAC_1 (0x06)
+#define NID_IO_DAC_2 (0x07)
+
+#define NID_WIDGET_MIC_1_MUX (0x09)
+#define NID_WIDGET_PGA_1 (0x0A)
+#define NID_WIDGET_PGA_2 (0x0B)
+
+#define NID_PORT_E (0x0C)
+#define NID_PORT_B (0x0D)
+#define NID_PORT_D (0x0E)
+#define NID_PORT_H (0x16)
+#define NID_PORT_A (0x11)
+#define NID_PORT_G (0x12)
+
+
+struct wm8860_spec {
+	struct hda_gen_spec gen;
+	/* mixer control */
+	const struct snd_kcontrol_new *mixers[20];
+	int mixers_count;
+	/* Initialization of the codec */
+	const struct hda_verb *init_verbs;
+	const struct hda_verb *uninit_verbs;
+	/* playback */
+	unsigned int dac_nids_count;
+	const hda_nid_t *dac_nids;
+	/* capture */
+	unsigned int adc_nids_count;
+	const hda_nid_t *adc_nids;
+	int mic_1_selection;
+	/* capture source */
+	const struct hda_input_mux *input_mux;
+	const hda_nid_t *capsrc_nids;
+};
+
+/*
+ * initialization (common callbacks)
+ */
+static int wm8860_init(struct hda_codec *codec)
+{
+	struct wm8860_spec *spec = codec->spec;
+
+	snd_hda_sequence_write(codec, spec->init_verbs);
+	return 0;
+}
+
+static int wm8860g_build_controls(struct hda_codec *codec)
+{
+	struct wm8860_spec *spec = codec->spec;
+	unsigned int i;
+	int err;
+
+	for (i = 0; i < spec->mixers_count; i++) {
+		err = snd_hda_add_new_ctls(codec, spec->mixers[i]);
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+
+/*
+ * Playback callbacks:
+ */
+static int wm8860_playback_pcm_open(struct hda_pcm_stream *hinfo,
+	struct hda_codec *codec,
+	struct snd_pcm_substream *substream)
+{
+	snd_hda_codec_write(codec, NID_PARAMETER, 0, AC_VERB_SET_GPIO_DATA,
+		GPIO_MUTE_DISABLE | GPIO_AMPLIFICATION_ENABLE);
+	msleep(20);
+	return 0;
+}
+
+static int wm8860_playback_pcm_close(struct hda_pcm_stream *hinfo,
+	struct hda_codec *codec,
+	struct snd_pcm_substream *substream)
+{
+	snd_hda_codec_write(codec, NID_PARAMETER, 0, AC_VERB_SET_GPIO_DATA,
+		GPIO_MUTE_ENABLE | GPIO_AMPLIFICATION_ENABLE);
+	return 0;
+}
+
+static int wm8860_playback_pcm_prepare(struct hda_pcm_stream *hinfo,
+	struct hda_codec *codec,
+	unsigned int stream_tag,
+	unsigned int format,
+	struct snd_pcm_substream *substream)
+{
+	struct wm8860_spec *spec = codec->spec;
+
+	snd_hda_codec_write(codec, spec->dac_nids[substream->number], 0,
+		AC_VERB_SET_POWER_STATE, AC_PWRST_D0);
+	snd_hda_codec_setup_stream(codec, spec->dac_nids[substream->number],
+		stream_tag, 0, format);
+	return 0;
+}
+
+static int wm8860_playback_pcm_cleanup(struct hda_pcm_stream *hinfo,
+	struct hda_codec *codec,
+	struct snd_pcm_substream *substream)
+{
+	struct wm8860_spec *spec = codec->spec;
+
+	snd_hda_codec_cleanup_stream(codec, spec->dac_nids[substream->number]);
+	snd_hda_codec_write(codec, spec->dac_nids[substream->number], 0,
+		AC_VERB_SET_POWER_STATE, AC_PWRST_D3);
+	return 0;
+}
+
+/*
+ * Capture callbacks:
+ */
+static int wm8860_capture_pcm_open(struct hda_pcm_stream *hinfo,
+	struct hda_codec *codec,
+	struct snd_pcm_substream *substream)
+{
+	struct wm8860_spec *spec = codec->spec;
+
+	if (spec->adc_nids[substream->number] != NID_IO_MIC_1)
+		return 0;
+	if (spec->mic_1_selection < 0) {
+		spec->mic_1_selection = substream->number;
+		if (spec->capsrc_nids[substream->number] == NID_PORT_B)
+			snd_hda_codec_write(codec, NID_WIDGET_MIC_1_MUX, 0,
+				AC_VERB_SET_CONNECT_SEL, 0x00);
+		else
+			snd_hda_codec_write(codec, NID_WIDGET_MIC_1_MUX, 0,
+				AC_VERB_SET_CONNECT_SEL, 0x01);
+		return 0;
+	}
+	snd_printk(KERN_WARNING
+		"Try to open a channel already open in Numeric/Analogic\n");
+	return -EBUSY;
+
+}
+
+static int wm8860_capture_pcm_close(struct hda_pcm_stream *hinfo,
+	struct hda_codec *codec,
+	struct snd_pcm_substream *substream)
+{
+	struct wm8860_spec *spec = codec->spec;
+
+	if (spec->adc_nids[substream->number] != NID_IO_MIC_1)
+		return 0;
+	if (spec->mic_1_selection == substream->number) {
+		spec->mic_1_selection = -1;
+		return 0;
+	}
+	snd_printk(KERN_WARNING
+		"Try to close a stream with Numeric/Analogic error\n");
+	return -EFAULT;
+}
+
+static int wm8860_capture_pcm_prepare(struct hda_pcm_stream *hinfo,
+	struct hda_codec *codec,
+	unsigned int stream_tag,
+	unsigned int format,
+	struct snd_pcm_substream *substream)
+{
+	struct wm8860_spec *spec = codec->spec;
+
+	snd_hda_codec_write(codec, spec->adc_nids[substream->number], 0,
+		AC_VERB_SET_POWER_STATE, AC_PWRST_D0);
+	snd_hda_codec_setup_stream(codec, spec->adc_nids[substream->number],
+		stream_tag, 0, format);
+	return 0;
+}
+
+static int wm8860_capture_pcm_cleanup(struct hda_pcm_stream *hinfo,
+	struct hda_codec *codec,
+	struct snd_pcm_substream *substream)
+{
+	struct wm8860_spec *spec = codec->spec;
+
+	snd_hda_codec_cleanup_stream(codec, spec->adc_nids[substream->number]);
+	snd_hda_codec_write(codec, spec->adc_nids[substream->number], 0,
+		AC_VERB_SET_POWER_STATE, AC_PWRST_D3);
+	return 0;
+}
+
+static const struct hda_pcm_stream wm8860_pcm_analog_playback = {
+	.substreams = 1,
+	.channels_min = 2,
+	.channels_max = 2,
+	.nid = 0,
+	.ops = {
+		.open = wm8860_playback_pcm_open,
+		.prepare = wm8860_playback_pcm_prepare,
+		.cleanup = wm8860_playback_pcm_cleanup,
+		.close = wm8860_playback_pcm_close,
+	},
+	.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_FLOAT_LE,
+};
+
+static const struct hda_pcm_stream wm8860_pcm_analog_capture = {
+	.substreams = 4,
+	.channels_min = 2,
+	.channels_max = 2,
+	.nid = 0,
+	.ops = {
+		.open = wm8860_capture_pcm_open,
+		.prepare = wm8860_capture_pcm_prepare,
+		.cleanup = wm8860_capture_pcm_cleanup,
+		.close = wm8860_capture_pcm_close,
+	},
+	.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_FLOAT_LE,
+};
+
+static int wm8860_build_pcms(struct hda_codec *codec)
+{
+	struct wm8860_spec *spec = codec->spec;
+	struct hda_pcm *info;
+
+	info = snd_hda_codec_pcm_new(codec, "wm8860");
+	if (!info)
+		return -ENOMEM;
+
+	info->stream[SNDRV_PCM_STREAM_PLAYBACK] = wm8860_pcm_analog_playback;
+	info->stream[SNDRV_PCM_STREAM_PLAYBACK].channels_max =
+		spec->dac_nids_count;
+	info->stream[SNDRV_PCM_STREAM_PLAYBACK].nid = spec->dac_nids[0];
+	info->stream[SNDRV_PCM_STREAM_CAPTURE] = wm8860_pcm_analog_capture;
+	info->stream[SNDRV_PCM_STREAM_CAPTURE].substreams =
+		spec->adc_nids_count;
+	info->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->adc_nids[0];
+	return 0;
+}
+
+static void wm8860_shutup(struct hda_codec *codec)
+{
+	snd_hda_shutup_pins(codec);
+	snd_hda_codec_write(codec, NID_PARAMETER, 0, AC_VERB_SET_GPIO_DATA,
+		GPIO_MUTE_ENABLE | GPIO_AMPLIFICATION_DISABLE);
+}
+
+static void wm8860_free(struct hda_codec *codec)
+{
+	struct wm8860_spec *spec = codec->spec;
+
+	if (!spec)
+		return;
+	snd_hda_sequence_write(codec, spec->uninit_verbs);
+	snd_hda_gen_spec_free(&spec->gen);
+	kfree(spec);
+	snd_hda_detach_beep_device(codec);
+}
+
+static struct hda_codec_ops wm8860g_patch_ops = {
+	.build_controls = wm8860g_build_controls,
+	.build_pcms = wm8860_build_pcms,
+	.init = wm8860_init,
+	.free = wm8860_free,
+};
+
+/*
+ * Automatic parse of I/O pins from the BIOS configuration
+ */
+static int wm8860_auto_build_controls(struct hda_codec *codec)
+{
+	int err;
+
+	err = snd_hda_gen_build_controls(codec);
+	if (err < 0)
+		return err;
+	return 0;
+}
+
+static const struct hda_codec_ops wm8860_auto_patch_ops = {
+	.build_controls = wm8860_auto_build_controls,
+	.build_pcms = snd_hda_gen_build_pcms,
+	.init = snd_hda_gen_init,
+	.free = snd_hda_gen_free,
+	.unsol_event = snd_hda_jack_unsol_event,
+	.reboot_notify = wm8860_shutup,
+};
+
+static hda_nid_t wm8860g_dac_nids[] = {
+	NID_IO_DAC_2, NID_IO_DAC_1
+};
+
+static hda_nid_t wm8860g_adc_nids[] = {
+	NID_IO_MIC_1, NID_IO_ADC_1, NID_IO_MIC_1, NID_IO_MIC_2
+};
+
+static hda_nid_t wm8860g_capsrc_nids[] = {
+	NID_PORT_B, NID_PORT_E, NID_PORT_D, NID_PORT_H
+};
+
+static struct hda_input_mux wm8860g_capture_source = {
+	.num_items = 4,
+	.items = {
+		{ "Analog Rear", NID_IO_MIC_1 }, /* port-B */
+		{ "Analog Front", NID_IO_ADC_1 }, /* port-E */
+		{ "Numeric Left", NID_IO_MIC_1 }, /* port-B */
+		{ "Numeric Right", NID_IO_ADC_1 }, /* port-E */
+	},
+};
+
+static struct snd_kcontrol_new wm8860g_playback_mixers[] = {
+	HDA_CODEC_VOLUME("Analog Front Playback Volume", NID_IO_DAC_2,
+		0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Analog Front Playback Switch", NID_IO_DAC_2,
+		0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("Analog Rear Playback Volume", NID_IO_DAC_1,
+		0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Analog Rear Playback Switch", NID_IO_DAC_1,
+		0x0, HDA_OUTPUT),
+	{ /* end */ }
+};
+
+/* capture */
+static struct snd_kcontrol_new wm8860g_capture_mixers[] = {
+	/*
+	 * Analog section:
+	 */
+	HDA_CODEC_VOLUME("Analog Rear mics Capture Volume", NID_WIDGET_PGA_2,
+		0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Analog Rear mics Capture Switch", NID_WIDGET_PGA_2,
+		0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("Analog Front mics Capture Volume", NID_WIDGET_PGA_1,
+		0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Analog Front mics Capture Switch", NID_WIDGET_PGA_1,
+		0x0, HDA_OUTPUT),
+	/*
+	 * Numeric section:
+	 */
+	HDA_CODEC_VOLUME("Numeric Left mics Capture Volume", NID_PORT_D,
+		0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("Numeric Left mics Capture Switch", NID_PORT_D,
+		0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME("Numeric Right mics Capture Volume", NID_PORT_H,
+		0x0, HDA_INPUT),
+	HDA_CODEC_MUTE("Numeric Right mics Capture Switch", NID_PORT_H,
+		0x0, HDA_INPUT),
+	{ /* end */ }
+};
+
+static const struct hda_verb wm8860g_capture_init_verbs[] = {
+	/* ---------------------------------
+	 * reset codec to have all the time the good configuration:
+	 * Note: the RESET is a command ==> no value needed
+	 * --------------------------------- */
+	{NID_PARAMETER, AC_VERB_SET_CODEC_RESET, 0},
+	/* ---------------------------------
+	 * Set all output and input to mute before configuring device
+	 *---------------------------------*/
+	/* Mute All Input */
+	{NID_WIDGET_PGA_1, AC_VERB_SET_AMP_GAIN_MUTE,
+		SET_AMP_STEREO | AC_AMP_MUTE},
+	{NID_WIDGET_PGA_2, AC_VERB_SET_AMP_GAIN_MUTE,
+		SET_AMP_STEREO | AC_AMP_MUTE},
+	/* mute input port: */
+	{NID_WIDGET_PGA_1, AC_VERB_SET_AMP_GAIN_MUTE,
+		SET_AMP_STEREO | AC_AMP_MUTE},
+	{NID_WIDGET_PGA_2, AC_VERB_SET_AMP_GAIN_MUTE,
+		SET_AMP_STEREO | AC_AMP_MUTE},
+	/* mute Output port: */
+	{NID_IO_DAC_1, AC_VERB_SET_AMP_GAIN_MUTE,
+		SET_AMP_STEREO | AC_AMP_MUTE},
+	{NID_IO_DAC_2, AC_VERB_SET_AMP_GAIN_MUTE,
+		SET_AMP_STEREO | AC_AMP_MUTE},
+	/* ---------------------------------
+	 * Configure ADC-1
+	 * --------------------------------- */
+	{NID_IO_ADC_1, AC_VERB_SET_STREAM_FORMAT,
+		  AC_FMT_BASE_48K
+		| (0 << AC_FMT_MULT_SHIFT)
+		| (0 << AC_FMT_DIV_SHIFT)
+		| AC_FMT_BITS_32
+		| (CHANNEL_STEREO << AC_FMT_CHAN_SHIFT)},
+	/* ---------------------------------
+	 * Configure MIC-1
+	 * --------------------------------- */
+	{NID_IO_MIC_1, AC_VERB_SET_STREAM_FORMAT,
+		  AC_FMT_BASE_48K
+		| (0 << AC_FMT_MULT_SHIFT)
+		| (0 << AC_FMT_DIV_SHIFT)
+		| AC_FMT_BITS_32
+		| (CHANNEL_STEREO << AC_FMT_CHAN_SHIFT)},
+	/* ---------------------------------
+	 * Configure MIC-2
+	 * --------------------------------- */
+	{NID_IO_MIC_2, AC_VERB_SET_STREAM_FORMAT,
+		  AC_FMT_BASE_48K
+		| (0 << AC_FMT_MULT_SHIFT)
+		| (0 << AC_FMT_DIV_SHIFT)
+		| AC_FMT_BITS_32
+		| (CHANNEL_STEREO << AC_FMT_CHAN_SHIFT)},
+	/* ---------------------------------
+	 * Configure DAC-1
+	 * --------------------------------- */
+	{NID_IO_DAC_1, AC_VERB_SET_STREAM_FORMAT,
+		  AC_FMT_BASE_48K
+		| (0 << AC_FMT_MULT_SHIFT)
+		| (0 << AC_FMT_DIV_SHIFT)
+		| AC_FMT_BITS_32
+		| (CHANNEL_STEREO << AC_FMT_CHAN_SHIFT)},
+	/* ---------------------------------
+	 * Configure DAC-2
+	 * --------------------------------- */
+	{NID_IO_DAC_2, AC_VERB_SET_STREAM_FORMAT,
+		  AC_FMT_BASE_48K
+		| (0 << AC_FMT_MULT_SHIFT)
+		| (0 << AC_FMT_DIV_SHIFT)
+		| AC_FMT_BITS_32
+		| (CHANNEL_STEREO << AC_FMT_CHAN_SHIFT)},
+	/* ---------------------------------
+	 * configure Port-E specification:
+	 * --------------------------------- */
+	{NID_PORT_E, AC_VERB_SET_CONFIG_DEFAULT_BYTES_3,
+		AC_JACK_LOC_EXTERNAL | AC_JACK_LOC_FRONT},
+	{NID_PORT_E, AC_VERB_SET_CONFIG_DEFAULT_BYTES_2,
+		(AC_JACK_MIC_IN<<8) | AC_JACK_CONN_UNKNOWN},
+	{NID_PORT_E, AC_VERB_SET_CONFIG_DEFAULT_BYTES_1,
+		(AC_JACK_COLOR_UNKNOWN<<8) | AC_DEFCFG_MISC_NO_PRESENCE},
+	{NID_PORT_E, AC_VERB_SET_CONFIG_DEFAULT_BYTES_0,
+		SINGLE_PIN_WIDGET_ONLY},
+	/* ---------------------------------
+	 * Configure port B specification
+	 * --------------------------------- */
+	{NID_PORT_B, AC_VERB_SET_CONFIG_DEFAULT_BYTES_3,
+		AC_JACK_LOC_EXTERNAL | AC_JACK_LOC_REAR},
+	{NID_PORT_B, AC_VERB_SET_CONFIG_DEFAULT_BYTES_2,
+		(AC_JACK_MIC_IN<<8) | AC_JACK_CONN_UNKNOWN},
+	{NID_PORT_B, AC_VERB_SET_CONFIG_DEFAULT_BYTES_1,
+		(AC_JACK_COLOR_UNKNOWN<<8) | AC_DEFCFG_MISC_NO_PRESENCE},
+	{NID_PORT_B, AC_VERB_SET_CONFIG_DEFAULT_BYTES_0,
+		SINGLE_PIN_WIDGET_ONLY},
+	{NID_PORT_B, VERB_SET_DIFFERENTIAL_MODE,
+		DIFFERENTIAL_FULL},
+	/* ---------------------------------
+	 * Configure port D specification
+	 * --------------------------------- */
+	{NID_PORT_D, AC_VERB_SET_CONFIG_DEFAULT_BYTES_3,
+		AC_JACK_LOC_EXTERNAL | AC_JACK_LOC_LEFT},
+	{NID_PORT_D, AC_VERB_SET_CONFIG_DEFAULT_BYTES_2,
+		(AC_JACK_MIC_IN<<8) | AC_JACK_CONN_UNKNOWN},
+	{NID_PORT_D, AC_VERB_SET_CONFIG_DEFAULT_BYTES_1,
+		(AC_JACK_COLOR_UNKNOWN<<8) | AC_DEFCFG_MISC_NO_PRESENCE},
+	{NID_PORT_D, AC_VERB_SET_CONFIG_DEFAULT_BYTES_0,
+		SINGLE_PIN_WIDGET_ONLY},
+	/* ---------------------------------
+	 * Configure port H specification
+	 * --------------------------------- */
+	{NID_PORT_D, AC_VERB_SET_CONFIG_DEFAULT_BYTES_3,
+		AC_JACK_LOC_EXTERNAL | AC_JACK_LOC_RIGHT},
+	{NID_PORT_D, AC_VERB_SET_CONFIG_DEFAULT_BYTES_2,
+		(AC_JACK_MIC_IN<<8) | AC_JACK_CONN_UNKNOWN},
+	{NID_PORT_D, AC_VERB_SET_CONFIG_DEFAULT_BYTES_1,
+		(AC_JACK_COLOR_UNKNOWN<<8) | AC_DEFCFG_MISC_NO_PRESENCE},
+	{NID_PORT_D, AC_VERB_SET_CONFIG_DEFAULT_BYTES_0,
+		SINGLE_PIN_WIDGET_ONLY},
+	/* ---------------------------------
+	 * GPIO configuration
+	 * --------------------------------- */
+	/* Set GPIO in manual mode (specific WM88XX): */
+	{NID_PARAMETER, 0x786, 0x00},
+	{NID_PARAMETER, AC_VERB_SET_GPIO_MASK,
+		GPIO_MUTE | GPIO_AMPLIFICATION},
+	{NID_PARAMETER, AC_VERB_SET_GPIO_DIRECTION,
+		GPIO_MUTE | GPIO_AMPLIFICATION},
+	{NID_PARAMETER, AC_VERB_SET_GPIO_DATA,
+		GPIO_MUTE_ENABLE | GPIO_AMPLIFICATION_ENABLE},
+	/* ---------------------------------
+	 * configuration done ... unmute neededs
+	 * --------------------------------- */
+	/* Un-mute input port: and set basic volume at 7dB,
+	 * 0 dB = 0x18, and each step is 0.5dB 7dB -> 0x0E dB + 0x18 = 0x26
+	 */
+
+	{NID_WIDGET_PGA_1, AC_VERB_SET_AMP_GAIN_MUTE,
+		SET_AMP_STEREO | 0x26},
+	{NID_WIDGET_PGA_2, AC_VERB_SET_AMP_GAIN_MUTE,
+		SET_AMP_STEREO | 0x26},
+	{NID_PORT_D, AC_VERB_SET_AMP_GAIN_MUTE,
+		SET_AMP_STEREO | 0x26},
+	{NID_PORT_H, AC_VERB_SET_AMP_GAIN_MUTE,
+		SET_AMP_STEREO | 0x26},
+	/* Un-mute Output port: set at 0dB = 0x7F correct basic volume */
+	/* Protect hardware speaker: set at -6.13dB => -6dB = 0x7F - 2*6 = 0x73 correct basic volume */
+	{NID_IO_DAC_2, AC_VERB_SET_AMP_GAIN_MUTE,
+		SET_AMP_STEREO | 0x73},
+	{NID_IO_DAC_1, AC_VERB_SET_AMP_GAIN_MUTE,
+		SET_AMP_STEREO | 0x73},
+	/* ---------------------------------
+	 * Start Streams (all time, no need to change state)
+	 * --------------------------------- */
+	/* Enables DAC and ADC: */
+	{NID_IO_DAC_1, AC_VERB_SET_POWER_STATE, AC_PWRST_D3},
+	{NID_IO_DAC_2, AC_VERB_SET_POWER_STATE, AC_PWRST_D3},
+	{NID_IO_ADC_1, AC_VERB_SET_POWER_STATE, AC_PWRST_D3},
+	{NID_IO_MIC_1, AC_VERB_SET_POWER_STATE, AC_PWRST_D3},
+	{NID_IO_MIC_2, AC_VERB_SET_POWER_STATE, AC_PWRST_D3},
+	/* Authorise the codec to start all IOs */
+	{NID_PARAMETER, AC_VERB_SET_POWER_STATE, AC_PWRST_D0},
+	{ /* end */ }
+};
+
+static const struct hda_verb wm8860g_capture_uninit_verbs[] = {
+	{NID_PARAMETER, AC_VERB_SET_GPIO_DATA,
+		GPIO_MUTE_ENABLE | GPIO_AMPLIFICATION_DISABLE},
+
+};
+
+static int patch_wm8860g(struct hda_codec *codec)
+{
+	struct wm8860_spec *spec;
+
+	spec = kzalloc(sizeof(*spec), GFP_KERNEL);
+	if (spec == NULL)
+		return -ENOMEM;
+	/* set new allocated data */
+	codec->spec = spec;
+	/* set basic conficuration of the codec: */
+	spec->init_verbs = wm8860g_capture_init_verbs;
+	spec->uninit_verbs = wm8860g_capture_uninit_verbs;
+	spec->mixers_count = 0;
+	/* Configure outputs: */
+	spec->dac_nids_count = ARRAY_SIZE(wm8860g_dac_nids);
+	spec->dac_nids = wm8860g_dac_nids;
+	spec->mixers[spec->mixers_count++] = wm8860g_playback_mixers;
+	/* configure Inputs: */
+	spec->adc_nids_count = ARRAY_SIZE(wm8860g_adc_nids);
+	spec->adc_nids = wm8860g_adc_nids;
+	spec->mic_1_selection = -1;
+	spec->mixers[spec->mixers_count++] = wm8860g_capture_mixers;
+	spec->input_mux = &wm8860g_capture_source;
+	spec->capsrc_nids = wm8860g_capsrc_nids;
+	codec->patch_ops = wm8860g_patch_ops;
+	codec->no_trigger_sense = 1;
+	return 0;
+}
+
+/*
+ * patch entries
+ */
+static const struct hda_device_id snd_hda_id_wolfson[] = {
+	HDA_CODEC_ENTRY(0x1aec8800, "WM8860", patch_wm8860g),
+	{ /* end */ }
+};
+MODULE_DEVICE_TABLE(hdaudio, snd_hda_id_wolfson);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Wolfson Multimedia HD-audio codec");
+
+static struct hda_codec_driver wolfson_driver = {
+	.id = snd_hda_id_wolfson,
+};
+
+module_hda_codec_driver(wolfson_driver);
